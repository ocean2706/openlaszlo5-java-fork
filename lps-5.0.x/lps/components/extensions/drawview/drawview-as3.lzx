<!---

    @copyright Copyright 2001-2012 Laszlo Systems, Inc.  All Rights Reserved.
               Use is subject to license terms.

    @access public
    @affects lzdrawview
    @topic LFC
    @subtopic Views
  -->
<library>

      <!-- TODO [jgrandy 6/1/2007] <otherwise> should be <when runtime="as2"> but that isn't currently supported -->
      <script when="immediate"><![CDATA[
        // Classes that implement an interface must obey the LZX
        // tag->class mapping convention and must be dynamic
        dynamic class $lzc$class_drawview extends LzView with DrawviewShared {
            if ($as3) {
                #passthrough (toplevel:true) {
                import flash.geom.Matrix;
                import flash.geom.Rectangle;
                import flash.display.Bitmap;
                import flash.display.BitmapData;
                import flash.display.Graphics;
                import flash.display.Sprite;
                }#
            }
            // Next two are part of the required LFC tag class protocol
            static var tagname:String = 'drawview';
            static var attributes = new LzInheritedHash(LzView.attributes);
            static var __colorcache:Object = {};
            // Prevent unneeded calls to clear()
            private var __dirty:Boolean = false;

            private var __path :Array = [];
            // Track whether this path is currently open or not.
            private var __pathisopen :Boolean = false;
            // whether to measure the width/height dimensions after redrawing
            var measuresize :Boolean = true;
            //const __MOVETO_OP :int = 1;
            //const __LINETO_OP :int = 2;
            //const __QCURVE_OP :int = 3;
            private var _lz = lz;

            // The container for the bitmap and all contexts
            var __drawcontainer:Sprite = null;
            // The container for the current context
            var __drawcontext:Sprite = null;
            // The container for __bitmapdata
            var __bitmapcontainer:Bitmap = null;
            // A background bitmap that contains all restored/transformed drawing state
            var __bitmapdata:BitmapData = null;
            var __norebuild:Boolean = false;
            // Contains a stack of drawing contexts, used by save/restore()
            var __contexts :Array = null;
            // contains context states, used for save/restore()
            var __contextstates:Array = null;
            

            // hash of image resources for drawImage
            static var images:Object = {};

            function $lzc$class_drawview (parent:LzNode? = null, attrs:Object? = null, children:Array? = null, instcall:Boolean = false) {
                super(parent, attrs, children, instcall);
            }

            override function construct(parent, args) {
                // default to bitmap caching on, unless clip = true
                if (args['cachebitmap'] == null && args['clip'] != true) args['cachebitmap'] = true;
                super.construct(parent, args);
                this.__contexts = [];
                this.__contextstates = [];
            }

            override function init () {
                super.init();
                this.context = this.createContainer();
                this.beginPath();
                this.$lzc$set_context(this.context);
            }

            function beginPath() {
                this.__path = [];
                this.__pathisopen = true;
                this.context.moveTo(0, 0);
            }

            function closePath() {
                if (this.__pathisopen && this.__path.length > 1) {
                    this.__pathisopen = false;
                    var path:Array = this.__path[0];
                    var op = path[0];
                    if (op == 1 || op == 2) {
                        //(op == this.__MOVETO_OP || op == this.__LINETO_OP)
                        //inlined:
                        //var x:Number = path[1];
                        //var y:Number = path[2];
                        //this.lineTo(x, y);
                        this.__path.push([2, path[1], path[2]]);
                    } else if (op == 3) {
                        //(op == this.__QCURVE_OP)
                        //inlined:
                        //var x:Number = path[3];
                        //var y:Number = path[4];
                        //this.lineTo(x, y);
                        this.__path.push([2, path[3], path[4]]);
                    }
                    //Debug.write('closePath', x, y);
                }
            }

            override function moveTo(x:Number, y:Number) {
                if (this.__pathisopen) {
                    // __MOVETO_OP
                    this.__path.push([1, x, y]);
                }
            }

            override function lineTo (x:Number, y:Number) {
                if (this.__pathisopen) {
                    // __LINETO_OP
                    this.__path.push([2, x, y]);
                }
            }

            override function quadraticCurveTo(cpx:Number, cpy:Number, x:Number, y:Number) {
                if (this.__pathisopen) {
                    // __QCURVE_OP
                    this.__path.push([3, cpx, cpy, x, y]);
                }
            }

            const bezierCurveTo_error:Number = 10;

            function bezierCurveTo(cp1x:Number, cp1y:Number, cp2x:Number, cp2y:Number, x:Number, y:Number) {
                var error:Number = this.bezierCurveTo_error;

                // Start from the cursor position, or (0, 0)
                var x0:Number = 0, y0:Number = 0;
                if (this.__path.length) {
                    var instr:Array = this.__path[this.__path.length - 1];
                    x0 = instr[instr.length - 2];
                    y0 = instr[instr.length - 1];
                }
                // The algorithm used is to recursively subdivide the cubic until
                // it's close enough to a quadratic, and then draw that.
                // The code below has the effect of
                //   function draw_cubic(cubic) {
                //     if (|midpoint(cubic)-midpoint(quadratic)| < error)
                //       draw_quadratic(qudratic);
                //     else
                //       map(draw_cubic, subdivide(cubic));
                //   }
                // where the recursion has been replaced by an explicit
                // work item queue.

                // To avoid recursion and undue temporary structure, the following
                // loop has a funny control flow.  Each iteration either pops
                // the next work item from queue, or creates two new work items
                // and pushes one to the queue while setting +points+ to the other one.
                // The loop effectively exits from the *middle*, when the next
                // work item is null.  (This continues to the loop test,
                // which then exits.)

                // each item is a list of control points, with a sentinel of null
                var work_items:Array = [null];
                // the current work item
                var points:Array = [{x: x0, y: y0}, {x: cp1x, y: cp1y}, {x: cp2x, y: cp2y}, {x: x, y: y}];
                while (points) {
                    // Posit a quadratic.  For C1 continuity, control point has to
                    // be at the intersection of the tangents.
                    var q1:* = this.intersection(points[0], points[1], points[2], points[3]);
                    var q0:Object = points[0];
                    var q2:Object = points[3];

                    if (q1 == null || q1 == -1) {
                        var flush:Boolean = true;
                        var start_first:Boolean = points[0].x == points[1].x && points[0].y == points[1].y;
                        var second_end:Boolean = points[2].x == points[3].x && points[2].y == points[3].y;
                        if (start_first) {
                            if (second_end) {
                                this.lineTo(q2.x, q2.y);
                            } else {
                                var q1:Object = points[2];
                                this.quadraticCurveTo(q1.x, q1.y, q2.x, q2.y);
                            }
                        } else if (second_end) {
                            var q1:Object = points[1];
                            this.quadraticCurveTo(q1.x, q1.y, q2.x, q2.y);
                        } else {
                            //both straight lines are collinear
                            //now we have to test whether they're identical or non-identical
                            if (q1 == null) {
                                q1 = {x:0,y:0};//default-value...
                                flush = false;
                            } else {
                                this.lineTo(q2.x, q2.y);
                            }
                        }
                        if (flush) {
                            points = work_items.pop();
                            continue;
                        }
                    }

                    // Compute the triangle, since the fringe is the subdivision
                    // if we need that and the peak is the midpoint which we need
                    // in any case
                    var m:Array = [points, [], [], []];
                    for (var i:int = 1; i < 4; i++) {
                        for (var j:int = 0; j < 4 - i; j++) {
                            var c0:Object = m[i-1][j];
                            var c1:Object = m[i-1][j+1];
                            m[i][j] = {x: (c0.x + c1.x)/2,
                                    y: (c0.y + c1.y)/2};
                        }
                    }

                    var qa:Object = this.midpoint(q0, q1);
                    var qb:Object = this.midpoint(q1, q2);
                    var qm:Object = this.midpoint(qa, qb);
                    // Is the midpoint of the quadratic close to the midpoint of
                    // the cubic?  If so, use it as the approximation.
                    if (this.distance(qm, m[3][0]) < error) {
                        this.quadraticCurveTo(q1.x, q1.y, q2.x, q2.y);
                        points = work_items.pop();
                        continue;
                    }
                    // Otherwise subdivide the cubic.  The first division is the
                    // next work item, and the second goes on the work queue.
                    var left:Array = new Array(4), right:Array = new Array(4);
                    for (var i:int = 0; i < 4; i++) {
                        left[i]  = m[i][0];
                        right[i] = m[3-i][i];
                    }
                    points = left;
                    work_items.push(right);
                }
            }

            function __getColor(val:*) :Object {
                var ccache:Object = this._lz.drawview.__colorcache;
                var cachedColor:Object = ccache[val];
                if (cachedColor == null) {
                    var coloralpha:Array = this._lz.ColorUtils.coloralphafrominternal(this._lz.ColorUtils.hextoint(val));
                    // NOTE: [2010-11-16 ptw] We can't distinguish
                    // between 'no alpha specified' and alpha == 1 in
                    // the internal representation.  If that's
                    // important, we need another representation
                    cachedColor = ccache[val] = {c: coloralpha[0], a: ((coloralpha[1] != 1) ? coloralpha[1] : null)};
                }
                return cachedColor;
            }

            function fill() {
                if (this.fillStyle instanceof this._lz.CanvasGradient) {
                    this.fillStyle.__applyFillTo(this.context);
                } else {
                    var color:Object = this.__getColor(this.fillStyle);
                    var alpha:Number = color.a != null ? color.a : this.globalAlpha;
                    if ($as2) { alpha *= 100; }
                    this.context.beginFill(color.c, alpha);
                }
                this.closePath();
                this.__playPath(this.context);
                this.context.endFill();
                if (this.measuresize) this.__updateSize();
            }

            function __playPath(context:*) :void {
                this.__dirty = true;
                if ($as2) { context._visible = false; }
                var path:Array = this.__path;
                //Debug.write(path, context);
                for (var i:int = 0; i < path.length; i++) {
                    var op:Array = path[i];
                    switch (op[0]) {
                        case 1:
                            //__MOVETO_OP
                            //Debug.write(context, 'moveTo', op[1], op[2]);
                            context.moveTo(op[1], op[2]);
                            break;
                        case 2:
                            //__LINETO_OP
                            //Debug.write(context, 'lineTo', op[1], op[2]);
                            context.lineTo(op[1], op[2]);
                            break;
                        case 3:
                            //__QCURVE_OP
                            //Debug.write(context, 'quadraticCurveTo', op[1], op[2], op[3], op[4]);
                            context.curveTo(op[1], op[2], op[3], op[4]);
                            break;
                    }
                }
                if ($as2) { context._visible = true; }
            }

            function stroke() {
                this.__updateLineStyle();
                this.__playPath(this.context);
                this.context.lineStyle(undefined);
                this.__updateSize();
            }

            function __updateLineStyle() {
                if (this.strokeStyle instanceof this._lz.CanvasGradient) {
                    this.strokeStyle.__applyStrokeTo(this.context);
                } else {
                    var color:Object = this.__getColor(this.strokeStyle);
                    var alpha:Number = color.a != null ? color.a : this.globalAlpha;
                    if ($as2) { alpha *= 100; }
                    var linecap = this.lineCap == 'butt' ? 'none' : this.lineCap;
                    this.context.lineStyle(this.lineWidth, color.c, alpha, false, 'normal',
                        linecap, this.lineJoin, this.miterLimit);
                }
            }

            function clear() {
                if (this['__dirty'] == false) return;
                this.__dirty = false;
                this.context.clear();
                if (this.__bitmapdata) {
                    this.clearRect(0,0,this.width,this.height);
                }
            }

            function createLinearGradient(x0:Number, y0:Number, x1:Number, y1:Number) {
                var dx:Number = x1-x0;
                var dy:Number = y1-y0;
                var r:Number = Math.atan2(dy, dx);
                var h:Number = Math.sqrt(dx*dx + dy*dy);
                var w:Number = h;
                var y:Number = Math.min(y0, y1);
                var x:Number = Math.min(x0, x1);

                var g:LzCanvasGradient = new LzCanvasGradient(this, {matrixType:"box", x:x, y:y, w:w, h:h, r:r}, false);
                //Debug.write('createLinearGradient', {matrixType:"box", x:x0, y:y0, w:w, h:h, r:r});
                return g;
            }

            function createRadialGradient(x0:Number, y0:Number, r0, x1:Number, y1:Number, r1:Number) {
                var w:Number = x1-x0;
                var h:Number = y1-y0;
                // Rotation doesn't seem to work
                var r:Number = r0 != null ? r0 : Math.atan2(h, w);
                var g:LzCanvasGradient = new LzCanvasGradient(this, {matrixType:"box", x:x0, y:y0, w:w, h:h, r:r}, true);
                //Debug.write('createRadialGradient', {matrixType:"box", x:x0, y:y0, w:w, h:h, r:r});
                return g;
            }

            var __tr:Number = 0;
            // accumulate rotation, radians is expected to be clockwise
            function rotate(radians:Number) {
                this.__saveToBitmap();

                this.__tr += radians * this.__radtodegfactor;
                if ($as2) {
                    this.__drawcontext._rotation = this.__tr;
                } else {
                    this.__drawcontext.rotation = this.__tr;
                }
            }
 
            // Saves the current drawing state to the bitmap
            function __saveToBitmap() {
                if (! this.__bitmapdata) {
                    // we don't yet have a bitmap, so create one
                    this.rebuildBitmap();
                }
                //if (! this.__bitmapdata) return;
                //var xoff = this.__measurewidth ? 0 : this.width * .5;
                //var yoff = this.__measureheight ? 0 : this.height * .5;

                // Offset to the center to ensure we can grab the whole drawing
                //if ($as2) {
                //    this.__drawcontext._x += xoff;
                //    this.__drawcontext._y += yoff;
                //} else {
                //    this.__drawcontext.x += xoff;
                //    this.__drawcontext.y += yoff;
                //}

                var m:Matrix = this.getIdentityMatrix();
                // Translate bitmap to original position to compensate for offset above
                //m.translate(-xoff, -yoff);

                if (this.__bitmapcontainer) {
                    // hide to avoid copying the bitmap onto itself
                    if ($as2) {
                        this.__bitmapcontainer._visible = false;
                    } else {
                        this.__bitmapcontainer.visible = false;
                    }
                }
                // copy drawcontainer state to the bitmap
                this.copyBitmap(this.__drawcontainer, this.width, this.height, this.__bitmapdata, m)
                if (this.__bitmapcontainer) {
                    if ($as2) {
                        this.__bitmapcontainer._visible = true;
                    } else {
                        this.__bitmapcontainer.visible = true;
                    }
                }

                // Move back to original position
                //if ($as2) {
                //    this.__drawcontext._x -= xoff;
                //    this.__drawcontext._y -= yoff;
                //} else {
                //    this.__drawcontext.x -= xoff;
                //    this.__drawcontext.y -= yoff;
                //}

                // Clear the context now that we've copied it
                this.context.clear();
            }

            // accumulate translation
            var __tx:Number = 0;
            var __ty:Number = 0;
            function translate(x:Number, y:Number) {
                this.__saveToBitmap();

                // scaling affects translation in swf
                this.__tx += x * this.__sx;
                this.__ty += y * this.__sy;
                if ($as2) {
                    this.__drawcontext._x = this.__tx;
                    this.__drawcontext._y = this.__ty;
                } else {
                    this.__drawcontext.x = this.__tx;
                    this.__drawcontext.y = this.__ty;
                }
            }

            // accumulate scale in the horizontal and vertical directions
            var __sx:Number = 1;
            var __sy:Number = 1;
            function scale(x:Number, y:Number) {
                this.__saveToBitmap();

                this.__sx *= x;
                this.__sy *= y;

                if ($as2) {
                    this.__drawcontext._xscale = this.__sx * 100;
                    this.__drawcontext._yscale = this.__sy * 100;
                } else {
                    this.__drawcontext.scaleX = this.__sx;
                    this.__drawcontext.scaleY = this.__sy;
                }
            }


            // shared by clip/button masking routines
            private function __drawPath(context) {
                this.closePath();
                context.clear();
                context.beginFill(0xff00ff, 0);
                this.__playPath(context);
                context.endFill();
            }

            // Listen for view size updates
            override function $lzc$set_width(w) {
                super.$lzc$set_width(w);
                if (this._setrescwidth || this._setrescheight) {
                    // stretches is on
                    this.__updateSize();
                }
                if (! this.__norebuild && this.__bitmapdata) this.rebuildBitmap();
            }

            override function updateWidth(w) {
                super.updateWidth(w);
                if (this._setrescwidth) {
                    // stretches is on
                    if ($as3) {
                        if (this.__drawcontainer) {
                            this.__drawcontainer.scaleX = this.width / this.unstretchedwidth;
                        }
                    }
                }
                if (! this.__norebuild && (this.__bitmapdata || ! this.measuresize)) this.rebuildBitmap();
            }

            override function $lzc$set_height(h) {
                super.$lzc$set_height(h);
                if (this._setrescwidth || this._setrescheight) {
                    // stretches is on
                    this.__updateSize();
                }
                if (! this.__norebuild && this.__bitmapdata) this.rebuildBitmap();
            }

            override function updateHeight(h) {
                super.updateHeight(h);
                if (this._setrescheight) {
                    // stretches is on
                    if ($as3) {
                        if (this.__drawcontainer) {
                            this.__drawcontainer.scaleY = this.height / this.unstretchedheight;
                        }
                    }
                }
                if (! this.__norebuild && (this.__bitmapdata || ! this.measuresize)) this.rebuildBitmap();
            }

            protected function __updateSize() :void {
                if (! this.__drawcontainer) return;
                var measureSize:Boolean = (this.hassetwidth == false || this.hassetheight == false || this._setrescwidth || this._setrescheight) && this.measuresize;
                if (! measureSize) return;

                var rebuildBitmapLater = false;
                if (this.__bitmapdata) {
                    // __bitmapcontainer needs to be removed while measuring the context's size
                    this.clearBitmap();
                    rebuildBitmapLater = true;
                }

                // don't rebuild bitmap in width/height setter
                this.__norebuild = true;

                // measure size, turning off scaling if stretches is on
                var width, height;
                var mc = this.__drawcontainer;
                if ($as3) {
                    // turn off scaling if stretches is on
                    if (this._setrescwidth) {
                        mc.scaleX = 1;
                    }
                    if (this._setrescheight) {
                        mc.scaleY = 1;
                    }

                    width = mc.width;
                    height = mc.height;
                } else {
                    width = mc._width;
                    height = mc._height;
                }

                var sizechanged = false;

                // update the size and scaling if stretches is on
                if (this.width !== width) {
                    sizechanged = true;
                    if (this.hassetwidth == false) {
                        this.updateWidth(width);
                    } else if (this._setrescwidth) {
                        // stretches is on...
                        this.updateWidth(width);
                    }
                }

                if (this.height !== height) {
                    sizechanged = true;
                    if (this.hassetheight == false) {
                        this.updateHeight(height);
                    } else if (this._setrescheight) {
                        // stretches is on...
                        this.updateHeight(height);
                    }
                }

                this.__norebuild = false
                if (rebuildBitmapLater) {
                    this.rebuildBitmap();
                }
            }

            function fillText(text:String, x:Number, y:Number, maxWidth = null) {
                if ($debug) {
                    Debug.warn('lz.drawview.fillText() is not currently supported in %w.', $runtime);
                }
            }

            function strokeText(text:String, x:Number, y:Number, maxWidth = null) {
                if ($debug) {
                    Debug.warn('lz.drawview.strokeText() is not currently supported in %w.', $runtime);
                }
            }
            function measureText(text:String) {
                if ($debug) {
                    Debug.warn('lz.drawview.measureText() is not currently supported in %w.', $runtime);
                }
            }

            if ($as3) {
                function clearMask() {
                    if (this.clipcontext) {
                        this.clipcontext.clear();
                        this.clipcontext = null;
                    }
                    if (this.clickcontext) {
                        this.clickcontext.clear();
                        this.clickcontext = null;
                    }
                }

                function clipPath() {
                    var masksprite = this.sprite.masksprite;
                    if (! masksprite) {
                        this.sprite.applyMask();
                        masksprite = this.sprite.masksprite;
                    }
                    if (! this.clipcontext) {
                        this.clipcontext = masksprite.graphics;
                    }
                    this.__drawPath(this.clipcontext);
                    // reset scale of mask
                    masksprite.scaleX = 1;
                    masksprite.scaleY = 1;
                }

                function clipButton() {
                    if (! this.clickable) this.setAttribute('clickable', true);
                    if (! this.sprite.clickregion) this.setAttribute('clickregion', null);
                    var clickregion:Sprite = this.sprite.clickregion
                    if (! this.clickcontext) {
                        this.sprite.hitArea = clickregion;
                        // update sizes in case scale changes
                        this.sprite.clickregionwidth = this.width;
                        this.sprite.clickregionheight = this.height;
                        // Add the clickregion as a child sprite to ensure the 
                        // mouse is active
                        this.sprite.addChild(clickregion);
                        //Debug.warn('clipButton', clickregion, this.sprite);
                        this.clickcontext = clickregion.graphics;
                    }
                    this.__drawPath(this.clickcontext);
                    // reset scale of clickregion 
                    clickregion.scaleX = 1;
                    clickregion.scaleY = 1;
                }


                if ($swf9) {
                    private var __sizelimit:Number = 2880 * 2880;
                } else { 
                    private var __sizelimit:Number = 4095 * 4095;
                }

                // Rebuild bitmap drawing layer
                private function rebuildBitmap () :void {
                    if (this.__norebuild || ! this.__drawcontainer) return;
                    var width = this.width;
                    var height = this.height;
                    if (width < 1 || height < 1) return;
                    // TODO: construct multiple bitmaps to deal with this limitaion
                    if ((width * height) > this.__sizelimit) {
                        if ($debug) {
                            Debug.warn('Drawview is too large for bitmap operations: drawImage(), save(), restore() and fillRect() may not work properly.  For best results, ensure this drawview is no larger than a total of %w pixels total, width x height.  See http://jira.openlaszlo.org/jira/browse/LPP-8697 for more details: %w', this.__sizelimit, this);
                        }
                        return;
                    }
                    if (this.__bitmapdata && width == this.__bitmapdata.width && height == this.__bitmapdata.height) return;

                    var bitmapdata:BitmapData = new flash.display.BitmapData(width, height, true, 0x000000ff);
                    if (bitmapdata) {
                        // copy any existing bitmap data
                        if (this.__bitmapdata) {
                            //this.copyBitmap(this.__bitmapdata, this.width, this.height, bitmapdata);
                            // clear any old data
                            this.clearBitmap();
                        }

                        this.__bitmapdata = bitmapdata;
                        this.__bitmapcontainer = new flash.display.Bitmap(bitmapdata);
                        this.__drawcontainer.addChildAt(this.__bitmapcontainer, 0);
                        if (this.oncontext.ready) {
                            // send oncontext so drawview knows to redraw
                            this.oncontext.sendEvent(this.context)
                        }
                    }
                }

                // destroy old bitmap data
                private function clearBitmap() :void {
                    if (this.__bitmapdata) {
                        this.__bitmapdata.dispose();
                        this.__bitmapdata = null;
                    }
                    if (this.__bitmapcontainer) {
                        this.__drawcontainer.removeChild(this.__bitmapcontainer);
                        this.__bitmapcontainer = null;
                    }
                }

                function getImage(name:String):BitmapData {
                    var cache = this._lz.drawview.images;
                    if (! cache[name]) {
                        var resinfo:Object = LzResourceLibrary[name];
                        var assetclass:Class;
                        // single frame resources get an entry in LzResourceLibrary which has
                        // 'assetclass' pointing to the resource Class object.
                        if (resinfo.assetclass is Class) {
                            assetclass = resinfo.assetclass;
                        } else {
                            // Multiframe resources have an array of Class objects in frames[]
                            assetclass = resinfo.frames[0];
                        }

                        if (this.resourceCache == null) {
                            this.resourceCache = [];
                        }
                        var asset = this.resourceCache[name];
                        if (asset == null) {
                            //Debug.write('CACHE MISS, new ',assetclass);
                            asset = new assetclass();
                            asset.scaleX = 1.0;
                            asset.scaleY = 1.0;
                            this.resourceCache[name] = asset;
                        }

                        var bounds:Rectangle = asset.getBounds(asset);

                        var assetsprite = this.sprite.addChild(asset);
                        cache[name] = copyBitmap(assetsprite, bounds.width, bounds.height);
                        this.sprite.removeChild(asset);
                    }

                    return cache[name];
                }

                // create a new container, only used at init time
                private function createContainer() {
                    var drawcontainer:Sprite = new Sprite();
                    drawcontainer.mouseChildren = false;
                    this.getDisplayObject().addChildAt(drawcontainer, 0);
                    this.__drawcontainer = drawcontainer;

                    this.__drawcontext = this.createDrawingContext();

                    return this.__drawcontext.graphics;
                }

                // Create new context to draw in
                private function createDrawingContext() {
                    var drawcontext:Sprite = new Sprite();
                    this.__drawcontainer.addChild(drawcontext);
                    return drawcontext;
                }

                function save() {
                    this.__contextstates.push({fillStyle: this.fillStyle, strokeStyle: this.strokeStyle, globalAlpha: this.globalAlpha, lineWidth: this.lineWidth, lineCap: this.lineCap, lineJoin: this.lineJoin, miterLimit: this.miterLimit});
                    // reset accumulated transforms
                    this.__sx = this.__sy = 1;
                    this.__tr = this.__tx = this.__ty = 0;

                    // Store this.context:MovieClip
                    this.__contexts.push(this.__drawcontext);

                    var drawcontext = createDrawingContext();

                    // Copy transforms from old context
                    drawcontext.x = this.__drawcontext.x;
                    drawcontext.y = this.__drawcontext.y;
                    drawcontext.rotation = this.__drawcontext.rotation;
                    drawcontext.scaleX = this.__drawcontext.scaleX;
                    drawcontext.scaleY = this.__drawcontext.scaleY;

                    this.__drawcontext = drawcontext;
                    this.context = drawcontext.graphics;
                }

                function restore() {
                    var state = this.__contextstates.pop();
                    if (state) {
                        for (var i in state) {
                            // restore to both regular values, since they'll match the context values already
                            this[i] = state[i];
                        }
                    }

                    if (this.__contexts.length) {
                        this.__saveToBitmap();
                        this.__drawcontainer.removeChild(this.__drawcontext);
                        this.__drawcontext = this.__contexts.pop();
                        this.context = this.__drawcontext.graphics;
                    }
                }
                // end as3
            } else {
                // See http://livedocs.adobe.com/flash/9.0/main/00001393.html
                private var __sizelimit = 2880 * 2880;

                // as2
                function clearMask() {
                    var maskclip = this.sprite.__LZmaskClip;
                    if (maskclip) {
                        maskclip.clear();
                    }
                }

                function clip() {
                    if ($debug) Debug.warn('lz.drawview.clip() is deprecated.  Use clipPath() instead.');
                    this.clipPath();
                }

                function clipPath() {
                    this.sprite.applyMask(true);
                    var maskclip = this.sprite.__LZmaskClip;
                    this.__drawPath(maskclip);
                    this.updateResourceSize();
                    // reset scale of mask
                    maskclip._xscale = 100;
                    maskclip._yscale = 100;
                }

                function clipButton() {
                    var mc:MovieClip = this.getDisplayObject();
                    //Debug.write('clip', this, mc, this.sprite.__LZbuttonRef);
                    if (! this['__clipmc']) {
                        this.__clipmc = this.sprite.__LZmovieClipRef.createEmptyMovieClip("$lzclipmc", 6);
                        this.sprite.__LZbuttonRef.setMask(this.__clipmc);
                    }
                    this.__drawPath(this.__clipmc);
                    this.updateResourceSize();
                }

                // Movieclip used to contain the bitmap, used so __bitmapcontainer can keep its place
                var __bitmapmc = null;

                // Rebuild bitmap drawing layer
                private function rebuildBitmap () :void {
                    if (this.__norebuild || ! this.__drawcontainer) return;
                    var width = this.width;
                    var height = this.height;
                    if (width < 1 || height < 1) return;
                    if ((width * height) > this.__sizelimit) {
                        if ($debug) {
                            Debug.warn('Drawview is too large for bitmap operations: drawImage(), save(), restore() and fillRect() may not work properly.  For best results, ensure this drawview is no larger than a total of %w pixels total, width x height.  See http://jira.openlaszlo.org/jira/browse/LPP-8697 for more details: %w', this.__sizelimit, this);
                        }
                        return;
                    }
                    if (this.__bitmapdata && width == this.__bitmapdata.width && height == this.__bitmapdata.height) return;
                    var bitmapdata = new flash.display.BitmapData(width, height, true, 0x000000ff);
                    if (bitmapdata) {
                        // clear any old data first
                        this.clearBitmap();

                        this.__bitmapdata = bitmapdata;
                        this.__bitmapmc = this.__bitmapcontainer.createEmptyMovieClip("__bitmapcontainer", 1);
                        this.__bitmapmc.attachBitmap(bitmapdata, 2, "auto", true);
                        this.__updateContextMenu();
                        if (this.oncontext.ready) {
                            // send oncontext so drawview knows to redraw
                            this.oncontext.sendEvent(this.context)
                        }
                    }
                }

                // destroy old bitmap data
                private function clearBitmap() :void {
                    if (this.__bitmapdata) {
                        this.__bitmapdata.dispose();
                        this.__bitmapdata = null;
                    }
                    if (this.__bitmapmc) {
                        this.__bitmapmc.removeMovieClip();
                        this.__bitmapmc = null;
                    }
                }

                override function $lzc$set_contextmenu (cmenu:LzContextMenu) :void {
                    super.$lzc$set_contextmenu(cmenu);
                    this.__updateContextMenu();
                }

                // Install/remove context menus on all drawing contexts and the bitmap
                private function __updateContextMenu():void {
                    // Install right-click context menu if there is one
                    var cmenu:LzContextMenu = this.sprite['__contextmenu'];
                    if (cmenu) {
                        var menu = cmenu.kernel.__LZcontextMenu();
                        if (this.__drawcontext) this.__drawcontext.menu = menu;
                        if (this.__bitmapcontainer) this.__bitmapcontainer.menu = menu;
                        for (var i = 0; i < this.__contexts.length; i++) {
                            if (this.__contexts[i]) {
                                this.__contexts[i].menu = menu;
                            }
                        }
                    } else {
                        if (this.__drawcontext) delete this.__drawcontext.menu
                        if (this.__bitmapcontainer) delete this.__bitmapcontainer.menu;
                        for (var i = 0; i < this.__contexts.length; i++) {
                            if (this.__contexts[i]) {
                                delete this.__contexts[i].menu;
                            }
                        }
                    }
                }

                function getImage(name:String):BitmapData {
                    var cache = this._lz.drawview.images;
                    if (! cache[name]) {
                        var container:MovieClip = createEmptyMovieClip("loader", getNextHighestDepth());
                        if (name.indexOf('http:') == 0 || name.indexOf('https:') == 0) {
                            var loader:MovieClip = container.createEmptyMovieClip("loader", container.getNextHighestDepth());
                            loader.loadMovie(name);
                            container.onEnterFrame = function() {
                                if (loader._width > 0) {
                                    cache[name] = this.copyBitmap(loader, loader._width, loader._height);
                                    delete this.onEnterFrame;
                                    container.removeMovieClip();
                                }
                            }
                        } else {
                            // measure size
                            container.attachMovie(name, 'resc', container.getNextHighestDepth());
                            cache[name] = this.copyBitmap(container, container._width, container._height);
                            container.removeMovieClip();
                        }
                    }
                    return cache[name];
                }

                // create a new container, only used at init time
                private function createContainer() {
                    var drawcontainer:MovieClip = this.getDisplayObject().createEmptyMovieClip("drawcontainer", 1);
                    this.__drawcontainer = drawcontainer.createEmptyMovieClip("drawing", drawcontainer.getNextHighestDepth());

                    // create bitmap container here to ensure we're behind the drawing context
                    var depth:Number = this.__drawcontainer.getNextHighestDepth();
                    this.__bitmapcontainer = this.__drawcontainer.createEmptyMovieClip('bitmap', depth);

                    // context and __drawcontext are the same for AS2
                    this.__drawcontext = this.createDrawingContext();
                    this.__updateContextMenu();

                    return this.__drawcontext;
                }

                // Create new context to draw in
                private function createDrawingContext() {
                    var depth:Number = this.__drawcontainer.getNextHighestDepth();
                    // context and __drawcontext are the same for AS2
                    return this.__drawcontainer.createEmptyMovieClip('draw' + depth, depth);
                }

                function save() {
                    this.__contextstates.push({fillStyle: this.fillStyle, strokeStyle: this.strokeStyle, globalAlpha: this.globalAlpha, lineWidth: this.lineWidth, lineCap: this.lineCap, lineJoin: this.lineJoin, miterLimit: this.miterLimit});

                    this.__sx = this.__sy = 1;
                    this.__tx = this.__ty = 0;

                    // Store this.context:MovieClip
                    this.__contexts.push(this.__drawcontext);

                    var newcontext = this.createDrawingContext();

                    // Copy from old context
                    newcontext._x = this.__drawcontext._x;
                    newcontext._y = this.__drawcontext._y;
                    newcontext._rotation = this.__drawcontext._rotation;
                    newcontext._xscale = this.__drawcontext._xscale;
                    newcontext._yscale = this.__drawcontext._yscale;

                    // context and __drawcontext are the same for AS2
                    this.__drawcontext = this.context = newcontext;
                }

                function restore() {
                    var state = this.__contextstates.pop();
                    if (state) {
                        // restore state
                        for (var i in state) {
                            this[i] = state[i];
                        }
                    }

                    if (this.__contexts.length) {
                        this.__saveToBitmap();
                        this.__drawcontext.removeMovieClip();
                        // context and __drawcontext are the same for AS2
                        this.__drawcontext = this.context = this.__contexts.pop();
                    }
                }
            } // End of as2/as3 conditionals

            function fillRect(x:Number, y:Number, w:Number, h:Number) {
                if (! w && ! h) return;
                this.__dirty = true;
                if (this.fillStyle instanceof this._lz.CanvasGradient) {
                    this.fillStyle.__applyFillTo(this.context);
                    this.__strokeRect(x,y,w,h);
                    this.context.endFill();
                } else {
                    var color:Object = this.__getColor(this.fillStyle);
                    var alpha:Number = color.a != null ? color.a : this.globalAlpha;
                    if (alpha == 1) {
                        // Use fillRect when we don't need alpha since it replaces the pixels
                        var rect:Rectangle = new flash.geom.Rectangle(x, y, w, h);
                        if (! this.__bitmapdata) {
                            this.rebuildBitmap();
                        }
                        this.__bitmapdata.fillRect(rect, color.c + 0xff000000);
                    } else {
                        // can't use fillRect() with alpha because it replaces the pixels
                        // fillRect() must not affect the current path, per http://www.whatwg.org/specs/web-apps/current-work/#simple-shapes-%28rectangles%29
                        var color:Object = this.__getColor(this.fillStyle);
                        var alpha:Number = color.a != null ? color.a : this.globalAlpha;
                        if ($as2) { alpha *= 100; }
                        this.context.beginFill(color.c, alpha);

                        this.__strokeRect(x,y,w,h);

                        this.context.endFill();

                    }
                }
            }

            // If both height and width are zero, this method has no effect, 
            // since there is no path to stroke (it's a point). If only one of 
            // the two is zero, then the method will draw a line instead (the 
            // path for the outline is just a straight line along the non-zero 
            // dimension).
            function __strokeRect(x:Number, y:Number, w:Number, h:Number) {
                if (w == 0 && h == 0) return;
                this.context.moveTo(x,y);
                if (w != 0) {
                    // top
                    this.context.lineTo(x + w,y);
                    if (h != 0) {
                        // right
                        this.context.lineTo(x + w,y + h);
                    }
                }
                if (h != 0) {
                    // bottom
                    this.context.lineTo(x,y + h);
                    if (w != 0) {
                        // left
                        this.context.lineTo(x,y);
                    }
                }

                // move back to the implicit 0,0 set in beginPath();
                this.context.moveTo(0,0);

                if (this.measuresize) this.__updateSize();
            }

            function clearRect(x:Number, y:Number, w:Number, h:Number) {
                if (! w && ! h) return;
                if (w < 1 || h < 1) return;
                this.__saveToBitmap();
                var rect:Rectangle = new flash.geom.Rectangle(x, y, w, h);
                this.__bitmapdata.fillRect(rect, 0x000000ff);
            }

            // The strokeRect(x, y, w, h) method must stroke the specified 
            // rectangle's path using the strokeStyle, lineWidth, lineJoin, 
            // and (if appropriate) miterLimit attributes. 
            function strokeRect(x:Number, y:Number, w:Number, h:Number) {
                if (! w && ! h) return;
                this.__dirty = true;
                this.__updateLineStyle();
                this.__strokeRect(x,y,w,h);
                this.context.lineStyle(undefined);
            }

            private function getIdentityMatrix():Matrix {
                return new flash.geom.Matrix();
            }

            function drawImage(image=null, x:Number=0, y:Number=0, w=null, h=null, r:Number=0) {
                // TODO: deal with runtime-loaded images
                if (image == null) {
                    // save state to the bitmap
                    this.__saveToBitmap();
                    // get a copy of the current bitmap
                    if (w == null) w = this.width;
                    if (h == null) h = this.height;
                    image = copyBitmap(this.__bitmapdata, w, h);
                    if (! image) return;
                } else if (typeof image == 'string') {
                    image = this.getImage(image);
                    if (! image) return;
                    if (w == null) w = image.width;
                    if (h == null) h = image.height;
                }

                this.__dirty = true;
                // default to image size per http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-drawimage

                var matrix:Matrix = this.getIdentityMatrix();

                // Apply accumulated translations
                var scalewidth:Number = w ? w / image.width : 1;
                var scaleheight:Number = h ? h / image.height : 1;
                matrix.scale(scalewidth * this.__sx, scaleheight * this.__sy);
                matrix.rotate(r + this.__tr);
                var tx:Number = x + this.__tx;
                var ty:Number = y + this.__ty;
                matrix.translate(tx, ty);

                if (! this.__bitmapdata) {
                    this.rebuildBitmap();
                }
                this.copyBitmap(image, this.width, this.height, this.__bitmapdata, matrix);
            }
            
            private function copyBitmap(from:*, w:Number, h:Number, to:BitmapData = null, m:Matrix = null) {
                // Trap errors caused by invalid width, height
                try {
                    var tmp:BitmapData = new flash.display.BitmapData(w, h, true, 0x000000ff);

                    tmp.draw(from);

                    // If to wasn't supplied, return the bitmap as-is.
                    if (! to) {
                        return tmp;
                    }
                    if (! m) {
                        m = this.getIdentityMatrix();
                    }
                    to.draw(tmp, m, null, null, null, true);
                    tmp.dispose();
                } catch (e) {
                }
            }
        } // End of drawview

        lz[$lzc$class_drawview.tagname] = $lzc$class_drawview;

        /**
          * <p>
          * The <tagname>LzCanvasGradient</tagname> is used by drawviews to describe a gradient fill.
          * </p>
          *
          * @shortdesc An object for describing gradient fills
          * @devnote LzCanvasGradient is an opaque object, which is used for assigning to
          * other attributes, e.g. fillStyle.  It is also used to add color stops.
          * An LzCanvasGradient is returned by drawview.createLinearGradient or
          * drawview.createRadialGradient.
          */
        class LzCanvasGradient {
            if ($as3) {
                #passthrough (toplevel:true) {
                import flash.geom.Matrix;
                }#
            }
            /** @access private */
            var __context :* = null;
            /** @access private */
            var __matrix :Matrix = null;
            /** @access private */
            var __type :String = null;
            /** @access private */
            var __colors :Array = null;
            /** @access private */
            var __alphas :Array = null;
            /** @access private */
            var __offsets :Array = null;

            function LzCanvasGradient(c:*, m:Object, isradial:Boolean) {
                this.__context = c;
                var matrix:Matrix = new flash.geom.Matrix();
                matrix.createGradientBox(m.w, m.h, m.r, m.x, m.y);
                this.__matrix = matrix;
                this.__type = isradial ? 'radial' : 'linear';
                this.__colors = [];
                this.__alphas = [];
                this.__offsets = [];
            }

            /**
            * Adds a new stop to a gradient. gradients are rendered such that at the starting point the colour at offset 0 is used, that at the ending point the color at offset 1 is used.  globalAlpha is stored for each gradient step added.
            * @param Number o: The offset this stop used for placement in the gradient.  Gradients are rendered such that for the starting point the colour at offset 0 is used, that at the ending point the color at offset 1 is used and all colors between those offsets are blended.  Must be less than 0 or greater than 1.
            * @param Number c: The color to be used at this color.  A hexadecimal value, e.g. 0xffffff
            */
            function addColorStop(o:Number, c:*) :void {
                this.__offsets.push(o * 255);
                var color:Object = this.__context.__getColor(c);
                this.__colors.push(color.c);
                var alpha:Number = color.a != null ? color.a : this.__context.globalAlpha;
                if ($as2) { alpha *= 100; }
                this.__alphas.push(alpha);
            }

            /**
            * @access private
            */
            function __applyFillTo(m:*) :void {
                // @devnote swf8: m instanceof MovieClip
                // @devnote swf9: m instanceof flash.display.Graphics
                m.beginGradientFill(this.__type, this.__colors, this.__alphas, this.__offsets, this.__matrix);
            }

            /**
            * @access private
            */
            function __applyStrokeTo(m:*) :void {
                // @devnote swf8: m instanceof MovieClip
                // @devnote swf9: m instanceof flash.display.Graphics
                m.lineGradientStyle(this.__type, this.__colors, this.__alphas, this.__offsets, this.__matrix);
            }
        }

        // create alias
        lz.CanvasGradient = LzCanvasGradient;
      ]]></script>

</library>
