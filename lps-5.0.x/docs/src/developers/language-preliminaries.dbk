<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="language-preliminaries">

  <title>Language Preliminaries</title>

  <para>LZX is an object-oriented, tag-based language that uses XML and JavaScript syntax to create
    the presentation layer of rich Internet applications. Typically these applications are compiled
    by the OpenLaszlo compiler. They may be deployed as standalone files, or they may be served by
    the OpenLaszlo Server. The specification of the language includes both a set of XML tags and a
    set of JavaScript APIs.</para>

  <para>The LZX language was designed to use familiar syntaxes and naming conventions so that
    experienced web developers would find it easy to learn and incorporate into their programming
    environments. At the same time LZX introduces new concepts and capabilities that make possible
    more fluid and responsive user interfaces to web applications than are possible with any other
    technology.</para>

  <para>A running LZX program takes place on a visual object called a canvas, which is basically a
    bit of screen real estate. On the canvas, autonomous boxes called views interact. These views
    may be nested logically and visually, and have programmable attributes, including
    <literal>size</literal>, <literal>position</literal>, <literal>background color</literal>, and
    so forth. Views may be used to contain resources, such as, for example, an image or a video, and
    may also be dynamically bound to any set of XML-formatted data. The attributes of any view can
    be set to be a function of the attributes of any other view or views, and virtually any
    attribute of a view can be animated — that is, set to vary over time.</para>

  <para>The LZX view system is similar to other view systems in many ways, but its implementations
    of data binding, attribute-constraints, and animation distinguish it from other UI technologies.</para>

  <para>LZX programs typically contain both declarative and procedural structures, and the language
    follows many naming conventions from CSS (Cascading Style Sheets). Programs written in LZX thus
    appear similar, on casual inspection, to DHTML applications with embedded JavaScript. LZX
    programs are conceptually different, however, from typical DHTML/JavaScript applications that
    are interpreted and rendered, or "executed," by the web browser. LZX programs, in contrast, are
    compiled on the server and downloaded as byte code for a target rendering engine.</para>

  <para>In the current implementation of the OpenLaszlo platform, LZX programs are compiled in the
    OpenLaszlo Server and downloaded either as Flash movies (.swf files) to be executed in the Flash
    Player plugged into an Internet browser, or compiled to DHTML which is downloaded to be executed
    by the browser's JavaScript engine. It's important to understand that the Flash Player is used
    only as an execution/rendering engine for the generated byte code: there's nothing inherent in
    LZX that marries it to Flash. In particular, LZX does not employ or rely upon the Flash object
    model.</para>

  <para>Similarly, because LZX programs are compiled by the OpenLaszlo Server the use of JavaScript
    in LZX programs is subtly different from its use in traditional web applications in which
    JavaScript is used to do things like communicate with the browser or generate HTML pages. Those
    functions are basically irrelevant in LZX applications. Thus, although the language design is
    rather traditional, the programming paradigm is fundamentally new.</para>
  <para>This chapter summarizes the traditional and innovative aspects of LZX. It's an overview, not
    a tutorial; after reading it you will be better able to decide how to go about learning the
    language. Depending on your background and experience, you may determine that you need to go
    learn some more about XML or object-oriented programming before addressing LZX. On the other
    hand, if you find these concepts accessible, you may want to jump right in and begin coding, in
    which case we suggest starting with the tutorial: <xref linkend="laszlo_basics"/>.</para>
  <para>For discussion of OpenLaszlo runtime and deployment modes, see the <link
    linkend="runtimedeploymodes">Preface</link>.
  </para>


  <section>
    <title>Overview of Syntax and Semantics</title>

    <para>In LZX, XML tags are used to create JavaScript objects, and JavaScript is used inside of
      LZX programs to manipulate objects created by tags. In most cases, anything that can be done
      with a tag can be accomplished in JavaScript, and vice versa. However, this equivalence is not
      universally true, and moreover one technique is virtually always vastly superior to another in
      any situation. <emphasis>Learning</emphasis> LZX basically comes down to learning the tags and
      APIs; <emphasis>mastering</emphasis> the language requires developing a subtle understanding
      of how the procedural and declarative approaches differ, and learning how and when to use
      each.</para>

    <para>LZX strictly adheres to XML and JavaScript syntax</para>


    <para>The following sections offer a brief refresher on the two kinds of LZX syntax. See below
      for a discussion of how JavaScript and XML syntaxes play together in typical LZX programs.</para>


    <section>
      <title>XML</title>

      <para>XML, the eXtensible Markup Language, is a W3C standard for encoding data. You will need
        a general familiarity with XML concepts in order to write programs in the LZX language for
        two reasons: in the first place, most of the functionality of LZX is implemented in an XML
        tag set. LZX programs themselves are valid XML documents; LZX programs that are not valid
        XML simply will not compile. Secondly, LZX programs only operate on data encapsulated in
        XML. See <xref linkend="xmlinscript"/> for a description of how to use XML in script.</para>

      <para>If you understand how tags and attributes are represented in XML, are comfortable with
        the concepts of roots and nodes, and know how nesting works you probably know enough to get
        started with LZX. For more information and links to any number of online books and tutorials
        about XML, visit the <ulink url="http://www.w3.org/XML/">W3C web site</ulink>.</para>
      <para>Another distinction between XML and JavaScript is that in XML the type names are
        lowercase ("string", "number"), while in JavaScript they're initial-capped, for example
          <literal>String</literal> and <literal>Number</literal>. The XML type names are used in
          <literal>&lt;attribute name="foo" type="string"/&gt;</literal>; they're lowercase
        for compatibility with the XML Schema Description datatypes. </para>

      <section>
        <title>XML and HTML</title>
        <para> If you have experience with HTML but not XML, you'll find many similarities. Here's
          some notes on how XML differs from the HTML, for people who are only familiar with HTML.
          These apply to all XML; they may particularly catch people up with respect to text markup,
          which uses tags (<literal>&lt;p&gt;</literal>,
          <literal>&lt;i&gt;</literal>, <literal>&lt;br&gt;</literal>) with the same
          names and meanings as HTML tags:</para>
        <itemizedlist spacing="compact">
          <listitem>
            <para>Case matters. <literal>&lt;b&gt;</literal> is different from
                <literal>&lt;B&gt;</literal>. (<literal>&lt;b&gt;</literal> exists
              in LZX as a tag for marking up bold text in a <literal>&lt;text&gt;</literal>
              element. <literal>&lt;B&gt;</literal> does not exist.)</para>
          </listitem>
          <listitem>
            <para>Attribute values must be quoted using <literal>"</literal> or
              <literal>'</literal>. <literal>&lt;view width=100&gt;</literal> is invalid
              XML; use <literal>&lt;view width='100'&gt;</literal> or <literal>&lt;view
                width="100"&gt;</literal> instead.</para>
          </listitem>
          <listitem>
            <para>Empty elements must be closed. <literal>&lt;br&gt;</literal> is valid
              HTML; in XML use <literal>&lt;br&gt;&lt;/br&gt;</literal> or
                <literal>&lt;br/&gt;</literal> instead.</para>
          </listitem>
        </itemizedlist>



      </section>
      <section>
        <title>Namespaces</title>
        <para> OpenLaszlo applications can be written with a namespace:</para>
        <programlisting>
  &lt;canvas xmlns="http://www.laszlosystems.com/2003/05/lzx"&gt;...&lt;/canvas&gt;
</programlisting>
        <para> or without:</para>
        <programlisting>
  &lt;canvas&gt;...&lt;/canvas&gt;
</programlisting>
        <para> If there is no namespace, the compiler defaults it to the LZX namespace
            (<literal>http://www.laszlosystems.com/2003/05/lzx</literal>). </para>
        <note>
          <para> A namespace has the same syntax as an URL, but it is not an URL; namespaces are
            really just hierarchical unique id's. In the above examples, the namespace doesn't point
            to anything in particular on the Laszlo Systems website. For more on namespaces, see the
              <ulink url="http://www.w3.org/TR/REC-xml-names/">W3C specification.</ulink>
          </para>
        </note>

      </section>
    </section>
    <section id="language-preliminaries.javascript">
      <title>JavaScript</title>

      <para>JavaScript is a language originally written at Netscape by Brendan Eich for
        incorporation in the Netscape 2.0 browser. It was instantly successful and widely adopted in
        other browsers, and to preserve its emerging value as a standard, the European Computer
        Manufacturer's Association (ECMA) codified the language as ECMAScript and now maintains
        control of its evolution. Although there may be subtle differences between any
        implementation of JavaScript and the language formally specified by the standards body, in
        colloquial usage the terms JavaScript and ECMAScript are often used interchangeably. While
        perhaps a little more accurate to say that "ECMAScript" refers to the pure language while
        "JavaScript" means both the language and the associated libraries that are available on most
        browsers, in this book we follow general usage and use the terms loosely, trusting that it
        will be clear from the context what we're talking about. The term "script" refers to any
        (procedural) code written in JavaScript.</para>

      <para>LZX incorporates a partial implementation of the <ulink
          url="http://www.ecma-international.org/publications/standards/Ecma-262.htm">ECMA-262
          Edition 3 specification</ulink>. See <xref linkend="ecmascript-and-lzx.differences"/> for
        more information.</para>


      <para>Depending on your background, you may find certain aspects of LZX familiar or foreign.
        For example, if you have experience with Java but not JavaScript, you will need to be aware
        of key differences in the languages.</para>

      <para>JavaScript's approach to object-oriented programming lacks the rigor of Java's. There
        are no packages or interfaces, for example, nor is it possible to finalize classes. Finally,
        the behavior of local and global variables in JavaScript is sometimes surprising to Java
        programmers.</para>

      <para>Conversely, if you are an experienced JavaScript programmer you may have to "unlearn"
        certain assumptions, in particular with regard to the availability of certain libraries and
        functions. For example, while the Math RegExp librarys are present in LZX, literal RegExp
        for regular expressions is not. Moreover, LZX has a more complete object-oriented
        programming model than does simple JavaScript. That is, LZX has classes, inheritance, and
        mixins.</para>

      <para>If you have experience with neither Java nor JavaScript you may want to first work
        through a JavaScript tutorial like the ones available at the <ulink
          url="https://developer.mozilla.org/en/JavaScript">MDN Doc Center</ulink> before delving
        too deeply into LZX.</para>


    </section>
    <section>
      <title>The "dot" syntax</title>

      <para>LZX employs the "dot" (period) syntax to indicate relationships between objects and
        their members. Consider the expression</para>

      <para>
        <literal>something.other</literal>
      </para>

      <para>When read as JavaScript, <literal>something</literal> refers to an object, and
          <literal>other</literal> refers to a property of that object, where a property might be,
        say, a method. Now consider the following LZX code fragment:</para>

      <programlisting>
&lt;view name="beatles"&gt; 
  &lt;view name="george"/&gt; 
&lt;/view&gt;
</programlisting>

      <para>in this case it may sometimes be convenient to refer to the interior view, "george" as</para>

      <para>
        <literal>beatles.george</literal>
      </para>

      <para>in which case <literal>george</literal> is a "child" of <literal>beatles</literal> .</para>

      <para>As will be discussed further below, LZX affords various ways to define attributes of,
        and methods on, objects or classes. For example, the following code samples (which create a
        view named <literal>myview</literal> and set its background color to red) are equivalent:</para>

      <para>JavaScript:</para>

      <programlisting>myview = new lz.view;</programlisting>

      <programlisting>myview.setAttribute ("bgcolor", "red");</programlisting>

      <para>XML tag:</para>

      <programlisting>&lt;view name="myview" bgcolor="red"/&gt;</programlisting>

      <para>and in both cases the background color of <literal>myview</literal> could be accessed by
        subsequent code as <literal>myview.bgcolor</literal> . The "dot" convention thus provides a
        convenient way of referring to objects regardless of how they came into existence — that is,
        whether by declarative tag or procedural code.</para>

    </section>
    <section>
      <title>Case Sensitivity</title>
      <para>
        <!-- fix typo per LPP-4847 IORIO 7 oct 2007 --> OpenLaszlo is entirely case-sensitive. This
        means that whenever you use a variable it must be in the case in which it was defined. </para>


    </section>
    <section>
      <title>Implicit "this" and "with"</title>
      <para> LZX has a behavior that is more Java-like than JavaScript-like. 'implicit this' is a
        term we use to describe the behavior of free references in LZX methods and handlers. In LZX
        classes, the object bound to `this` is implicitly 'in scope' in all methods and handlers, as
        it is in Java (this is _not_ the case in JavaScript). We added this feature to LZX because
        we felt it led to more intuitive and compact code. </para>
      <para> What this means is that in any method or handler in a class you can refer to the class
        attributes by name directly, without the prefix `this.`. (Hence the nickname 'implicit
        this'.) A concrete example: </para>
      <programlisting>
&lt;class name="foo"&gt;
   &lt;attribute name="attr" value="42" /&gt;

   &lt;method name="implicitAttrValue"&gt;
     return attr;
   &lt;/method&gt;

   &lt;method name="explicitAttrValue"&gt;
     return this.attr;
   &lt;/method&gt;
&lt;/class&gt;
</programlisting>
      <para> The two methods will return the same value. </para>
      <para> You should <emphasis>not</emphasis> rely on "implicit this" on the left-hand side (LHS)
        of an assignment expression. Doing so is dangerous because unless the property already
        exists in `this`, you will write a global. Consider: </para>
      <programlisting>
&lt;class name="bar"&gt;
   &lt;attribute name="attr" /&gt;

   &lt;method name="implicitSetAttrValue"&gt;
     attr = 7;
   &lt;/method&gt;

   &lt;method name="explicitSetAttrValue"&gt;
     this.attr = 7;
   &lt;/method&gt;
&lt;/class&gt;
</programlisting>
      <para> Because <literal>attr</literal> is not initialized, the implicit method may not find
          <literal>attr</literal> in the instance and will set the global variable
        <literal>attr</literal> instead. You should <emphasis>always</emphasis> explicitly use
          <literal>this</literal> on the left-hand side of any assignment. The compiler can help you
        find errors like this: If you compile your application with <literal>lzc -
          DwarnGlobalAssignments</literal>, the compiler will print a warning for every global
        assignment that your program makes. If you intend to make a global assignment, you can
        silence the warning by explicitly using `global.attr =`. For a complete description see
          <xref linkend="compiler"/>.</para>
      <para> `with` is a JavaScript primitive that can be used to establish scope. Free variables in
        the body of a `with` will be looked up first in the object that is the argument (and then in
        whatever the enclosing scope is).</para>
    </section>
    <section>
      <title>The LZX DTD and Schema</title>

      <para>An XML schema defines the LZX tag set and can be used to configure an editor. The DTD is
        also available for the curious, although there is no need for you to be aware of it for
        programming purposes.</para>

      <para>The LZX schema is used by the OpenLaszlo Compiler to ensure that LZX programs are
        formally correct. For example, the schema specifies what attributes can be included in an
        opening <literal>&lt;view&gt;</literal> tag. If your program contains a
          <literal>&lt;view&gt;</literal> tag that includes an attribute not defined by the
        schema, it will compile with a warning.</para>

      <para>LZX allows you to define your own tags. User defined tags do not get incorporated into
        the schema that is available to your editor, although they are used in the internal schema
        that the compiler uses to test that program's validity.</para>





    </section>
  </section>
  <section id="language-preliminaries.objects-and-attributes">
    <title>Objects and Attributes</title>


    <para>LZX incorporates the standard object-oriented programming concepts of inheritance,
      encapsulation, and polymorphism. In general, a tag in an OpenLaszlo program corresponds to an
      object that is an instance of the class of that name. For example, the
        <literal>&lt;view&gt;</literal> tag corresponds to an <literal>lz.view</literal>
      object.</para>

    <para>To a first approximation, then, LZX can be described as a rule-based declarative language
      for manipulating visual (JavaScript) objects called views, where rules are expressed as
      constraints on the values of the attributes of those objects.</para>

    <para>The following paragraphs summarize some of the key object-oriented aspects of the LZX
      language. These ideas are examined at greater length elsewhere in this Guide, particularly in
        <xref linkend="class-inheritance"/>.</para>


    <section>
      <title>Objects</title>

      <para>An object is a data type that contains named pieces of data. Depending on context, a
        named datum might be called a <emphasis>property</emphasis> or an
        <emphasis>attribute</emphasis> of that object. For example, each <literal>view</literal>
        object has attributes, such as height, width, horizontal position, vertical position, and so
        forth. Values are generally assigned to the attributes of objects when the objects are
        created; attributes that you do not specifically set are assigned default values.</para>

      <para>You can create new kinds of LZX objects by using the
        <literal>&lt;class&gt;</literal> tag. Each new class you create must be given a name
        and the name of a class that it's "extending." The newly created objects inherit all the
        properties of the class you extended, plus any additional properties you may define. For
        example consider the trivial case</para>

      <programlisting>&lt;class name="myview" extends="view"/&gt;</programlisting>

      <para>In this case you have defined a new kind of object called a <literal>myview</literal>
        that has all the properties of a <literal>view</literal>. <xref
          linkend="initialization-and-instantiation"/> discusses in depth when and how objects are
        defined in your code and built by the compiler at runtime.</para>


    </section>
    <section>
      <title>Attributes</title>

      <para>In LZX, the word "attribute" has two related but subtly different meanings, one
        syntactical and one semantic. In the XML, syntactical, sense, an attribute is a named value
        associated with an XML element and specified in that element's opening tag. Thus in the XML
        tag</para>

      <programlisting>&lt;boss demeanor="friendly"/&gt;</programlisting>

      <para><literal>demeanor</literal> is an attribute of the tag <literal>boss</literal> . This
        meaning of "attribute" applies whenever the context is XML structure. Note that the value
        assigned to an attribute is enclosed in double quotation marks.</para>

      <para>Because LZX tags correspond to JavaScript classes, "attribute" takes on the additional
        semantic weight of property of a JavaScript object. Thus the LZX tag</para>

      <programlisting>&lt;view height="20" width="30"/&gt;</programlisting>

      <para>causes the creation of a view object with the specified values for the attributes
          <literal>height</literal> and <literal>width</literal>.</para>

      <para>The <literal>&lt;attribute&gt;</literal> tag can be used to set JavaScript
        attributes of objects. For example,</para>

      <programlisting> 
&lt;view name="myview"&gt; 
  &lt;attribute name="height" value="20"/&gt; 
  &lt;attribute name="width" value="30"/&gt; 
&lt;/view&gt;  
</programlisting>

      <para>is equivalent, in LZX, to the earlier one-line version. Thus <literal>height</literal>
        is an attribute of the view, in the semantic sense, even though it is not in the XML sense
        of being contained in the opening tag. <literal>height</literal> is also an attribute, in
        the XML sense, of the first <literal>&lt;attribute&gt;</literal> tag. Its value can
        be referenced by script as <literal>myview.height</literal>.</para>

      <para>You also use the <literal>&lt;attribute&gt;</literal> tag to define new
        attributes for classes you create. For example</para>

      <informalexample role="live-example">
        <programlisting>
&lt;class name="froboz" extends="view"&gt; 
  &lt;attribute name="whatnot" value="17"/&gt; 
&lt;/class&gt;
</programlisting>
      </informalexample>

      <para>Defines a new kind of view object, <literal>froboz</literal>, that has the attributes
        that it inherited from view, plus the new attribute named <literal>whatnot</literal>.</para>

      <para>We have seen that attributes can be set, that is, assigned values, in LZX tags. It is
        also possible to set attribute values in script using the <literal>setAttribute()</literal>
        <literal>setAttribute()</literal> method. Additionally, values of attributes can be read, or
        "gotten" in script (but not in tags) using the <literal>.</literal> operator.</para>

      <para>Assume the existence of a view named <literal>johnny</literal>. This view may have been
        created by a tag or in script; how the view came into existence does not matter.</para>

      <para>The JavaScript code to set the height of this view to 100 pixels would be:</para>
      <para>
        <literal>johnny.setAttribute("height", 100);</literal>
      </para>

      <para>and to read the value the height would be</para>

      <para>
        <literal>johnny.height;</literal>
      </para>

      <para>Every time that an attribute is set, that is, every time the value of an attribute
        changes, an object called an <literal>event</literal> is generated. The next section
        discusses what events are, and how they work in LZX programs.</para>


    </section>
  </section>
  <section>
    <title>Events and Methods</title>


    <section>
      <title>Events</title>

      <para>Events are the mechanism by which objects communicate with each other when something
        changes. For example, an event might be generated when a mouse button is clicked, or when
        data arrives from a server, or when a view has been constructed.</para>

      <para>In LZX programs, events are not broadcast, but rather they are communicated in a
        point-to-point fashion using <literal>delegates</literal>, which are basically function
        pointers that are referenced when events happen. This implementation increases flexibility
        and reduces the overhead of using events. However, for the purposes of the discussion in
        this chapter we're going to ignore delegates and speak of events in a slightly less rigorous
        manner, saying, for example when such-and-such an event <emphasis>occurs</emphasis>, thus
        and such <emphasis>happens,</emphasis> leaving aside for now an explanation of
        <emphasis>how</emphasis> it happens.</para>

      <para>Views have defined events, as listed on the entry for
        <literal>&lt;view&gt;</literal> in the <ulink url="../reference/"
          type="laszlo-reference">LZX Reference Manual</ulink>. Many of these events that deal with
        user input, such as <literal>onblur</literal>, <literal>onclick</literal>,
          <literal>onkeydown</literal>, will be familiar to JavaScript programmers. Other events,
        such as <literal>onheight</literal> and <literal>onopacity</literal>, pertain to views'
        visible attributes. Finally, the <literal>oninit</literal> and
        <literal>onconstruct</literal> events are related to the creation of the instances of view
        objects. Similarly, other system-defined LZX objects such as Datasets (see below) have
        events associated with them.</para>

      <para>Events and attributes often work as pairs, and in fact, the default behavior of the
          <literal>setAttribute()</literal> method is to set the named property and send the event
        called "<literal>onx</literal>" + property. For instance, when a view changes its
        <literal>x</literal> (horizontal) position, it sends the event <literal>onx</literal> with
        the new value for its <literal>x</literal> property. This means that in addition to
        system-defined events, there exists an event for each attribute you define.</para>

      <para>When an event happens, control is transferred to its associated event-handler (if one is
        defined). Events can be sent with a single argument, which usually conveys information about
        the property that changed.</para>

      <para>Elsewhere in this Guide we discuss how events are implemented in LZX, and how the event
        architecture bears upon program design. In particular, <xref linkend="delegates"/> discusses
        the relationship between events and delegates.</para>


    </section>
    <section>
      <title>Methods</title>

      <para>In LZX, a method is a JavaScript function associated with a particular object.</para>

      <para>Functions are invoked using the <literal>()</literal> operator. Thus,</para>

      <programlisting>
&lt;view name="dog"&gt;   
  &lt;method name="bark"&gt; 
    &lt;!-- some JavaScript code --&gt; 
  &lt;/method&gt; 
&lt;/view&gt;
</programlisting>

      <para>Defines a function that is executed when invoked by name, as in</para>

      <para>
        <literal>dog.bark();</literal>
      </para>

      <para>In JavaScript, the <literal>this</literal> keyword is used to refer to the object
        through which the function was invoked. </para>

    </section>
    <section>
      <title>Handlers</title>
      <para> A handler is like a method. But whereas a method is invoked by its name, a handler must
        be associated with a particular event. The handler script will be executed when the
        referenced view receives an event with this name. For example,</para>

      <programlisting>
&lt;view&gt; 
  &lt;handler name="onclick"&gt; 
    &lt;!-- some JavaScript code --&gt; 
  &lt;/handler&gt; 
&lt;/view&gt;
</programlisting>

      <para>defines a function that is executed when the view is clicked on. Consider</para>

      <programlisting> 
&lt;view&gt; 
  &lt;method name="bark"&gt; 
    &lt;!-- some JavaScript code --&gt; 
  &lt;/method&gt; 
  &lt;handler name="onclick"&gt; 
    this.bark()  
  &lt;/handler &gt; 
&lt;/view&gt;
</programlisting>

      <para>When the view is clicked on, the <literal>onclick</literal> event causes the execution
        of the <literal>handler()</literal> which in turn invokes the method named
        <literal>bark()</literal>. Event handlers are often identified in an opening tag, as in</para>

      <programlisting>
&lt;view onclick="clickHandler()"&gt; 
  &lt;method name="clickHandler"&gt; 
    &lt;!-- some JavaScript code --&gt; 
  &lt;/method&gt; 
&lt;/view&gt; 
</programlisting>

      <para>There are three general categories of methods and handler:</para>
      <itemizedlist spacing="compact">
        <listitem>
          <para> "On init" methods that are invoked when their parent object is created;</para>
        </listitem>
        <listitem>
          <para> handlers that are invoked when their parent object receives a specified
          event;</para>
        </listitem>
        <listitem>
          <para> named methods that are explicitly invoked by other methods.</para>
        </listitem>
      </itemizedlist>

      <para>Note that you can define a method using conventional JavaScript syntax, but in LZX the
        preferred way to declare a method is with the <literal>&lt;method&gt;</literal> tag.</para>

      <para>Also note that in LZX, unlike many other object-oriented systems, you can override a
        method in an instance of an object. This topic is covered in <xref
          linkend="class-inheritance"/>.</para>


    </section>
  </section>
  <section>
    <title>Constraints</title>



    <para>In LZX, a constraint is an attribute whose value is a function of other attribute values.
      The syntax for coding a constraint is</para>

    <programlisting>$<replaceable>when</replaceable>{<replaceable>expression</replaceable>}</programlisting>

    <para>where:</para>
    <itemizedlist spacing="compact">
      <listitem>
        <para><literal>$</literal> is the token indicating a constraint</para>
      </listitem>
      <listitem>
        <para><literal>
            <replaceable>when</replaceable>
          </literal> is an optional compiler directive: <literal>immediately</literal>,
            <literal>once</literal>, or <literal>always</literal>.
              <literal>$always{<replaceable>expression</replaceable>}</literal> can be abbreviated
          to <literal>${<replaceable>expression</replaceable>}</literal>
        </para>
      </listitem>
      <listitem>
        <para><literal>{</literal> and <literal>}</literal> are tokens delimiting the expression to
          be evaluated</para>
      </listitem>
      <listitem>
        <para><literal>
            <replaceable>expression</replaceable>
          </literal> is a JavaScript expression</para>
      </listitem>
    </itemizedlist>

    <para>As we have seen above, whenever the value of an attribute changes, its
      <literal>on</literal> event is generated. Because a constraint is an attribute whose value is
      dependent upon the values of one or more other attribute(s), the value of the constraint is
      recalculated whenever it receives the <literal>on</literal> event for the attributes on which
      it depends.</para>

    <para>Consider</para>

    <programlisting>
&lt;view name="someView" 
      width="${someAttribute + someOtherAttribute}" 
 /&gt;
</programlisting>

    <para>The value of <literal>someView.width</literal> is recomputed whenever an
        <literal>onsomeAttribute</literal> or <literal>onsomeOtherAttribute</literal> event
      occurred.</para>

    <para>So for example</para>

    <programlisting>
&lt;view name="beatles" width="${this.paul.width + 28}"&gt; 
  &lt;view name="paul" onclick="clickhandler()" &gt; 
    &lt;!-- clickhandler method here to increase paul's width based on user clicking mouse --&gt; 
  &lt;/view&gt; 
&lt;/view&gt;
</programlisting>

    <para>The width of <literal>beatles</literal> will increase or decrease as a function of
        <literal>paul</literal>'s width; the expression <literal>this.paul.width + 28</literal> is a
      constraint.</para>

    <para>When the user clicks on the <literal>paul</literal> view, the clickhandler will adjust the
      size of the <literal>paul</literal> view. This change will be reported to the
        <literal>${this.paul.width + 28}</literal> constraint, which will then adjust the
        <literal>beatles</literal> view to the width of the <literal>paul</literal> view plus an
      additional 28 pixels. All of these steps are invisible to the user because they occur
      instantly.</para>

    <para>This, of course is a trivial example, but it serves to make the point that in declaring
      the structure of your objects in LZX you also declare the rules by which they will relate to
      each other. Constraints are a fundamental concept in LZX programming, and learning to "think
      in LZX" is a mostly a matter of learning to properly model your system's behavior in terms of
      the constraints on its constituent parts. <xref linkend="constraints"/> covers constraints in
      depth.</para>


    <section>
      <title>Lexical and View Hierarchies</title>

      <para>An LZX application is expressed as a hierarchy of objects, usually visual objects, all
        of which are contained in a single object called the Canvas. Recall that LZX programs are
        XML documents, the Canvas is the root element. The simplest LZX program is thus:</para>

      <programlisting>&lt;canvas/&gt;</programlisting>

      <para>This program compiles and executes, but has no output. As the simplest visual object is
        the View, a minimal LZX program would look something like:</para>

      <programlisting>
&lt;canvas&gt;
  &lt;view&gt;
    &lt;text&gt; Hello World!&lt;/text&gt; 
  &lt;/view&gt; 
&lt;/canvas&gt;
</programlisting>

      <para>This code clearly defines a hierarchy of three objects. We can make their visual
        relationship more visible by giving the canvas and view sizes and background colors:</para>

      <para>In this simple case, the lexical hierarchy in the code corresponds to the visual
        hierarchy in the canvas. In fact, a <literal>&lt;text&gt;</literal> object is an
        instance of a class derived from <literal>&lt;view&gt;</literal> . The typical LZX
        program repeats this pattern on a larger scale: the canvas contains views which contain
        other views, and so forth. Classes are used to replicate view groupings; components such as
        buttons, windows, input fields and sliders are examples of classes built from views.</para>

      <para>LZX affords a variety of ways to simplify the relationships among views. For example,
        there are several categories of layouts that handle the "housekeeping" of placing views in
        relationship to each other. These are described in <xref linkend="layout-and-design"/>.</para>

      <para>However, the relationship between the textual hierarchy in the code and the visual
        hierarchy on the canvas is not always as neat as in the example above. In particular, LZX's
        powerful data binding semantics make it possible for a single
        <literal>&lt;view&gt;</literal> tag in the text to cause the creation of an
        arbitrary number of instances of <literal>view</literal> objects. In such cases it becomes
        very important to have a precise way of talking about complex relationships among objects.
          <xref linkend="views"/> covers this topic in depth.</para>


    </section>
    <section>
      <title>Lexical Scope</title>

      <para>In LZX the concepts of local and global namespaces, or scopes, are basically the same as
        in JavaScript. Having said that, it should be pointed out that JavaScript follows rules that
        are sometimes surprising to Java Programmers.</para>

      <para>In JavaScript, all variables are global unless they are preceded by the keyword
          <literal>var</literal>.</para>

      <para>Thus</para>

      <programlisting>a = 7; // defines a global variable a</programlisting>

      <para>and</para>

      <programlisting>var a = 7 // defines a local variable a</programlisting>

      <para>This syntax means, for example, that an assignment in a method definition can set an
        instance of a global variable:</para>

      <programlisting>for (a = 0; a &lt;n; a++);</programlisting>

      <para>Creates a global variable named <literal>a</literal>, or changes the value of this
        variable if it already exists. What the programmer meant to write was</para>

      <programlisting>for (var a = 0; a &lt;n; a++);</programlisting>

      <para>In LZX, the <literal>name</literal> attribute is local and the <literal>id</literal>
        attribute is global. Thus</para>

      <informalexample role="live-example">
        <programlisting>
&lt;canvas&gt; 
  &lt;view name="john" id="grandfather"&gt; 
    &lt;view name="john" id="father"&gt; 
      &lt;view name="john" id="son"/&gt; 
    &lt;/view&gt; 
  &lt;/view&gt; 
&lt;/canvas&gt;
</programlisting>
      </informalexample>

      <para>is a valid name scheme. The innermost view can be referenced by
          <literal>canvas.john.john.john</literal> or simply <literal>son</literal>.</para>

      <para>As will be discussed below, functions created using the
        <literal>&lt;script&gt;</literal> tag can be accessed from anywhere in the program.</para>


    </section>
  </section>
  <section>
    <title>Data Access, Manipulation, and Binding</title>

    <para>LZX is designed to make it easy to write data-driven applications in which the values of
      data sources define the appearance and actions of the program. It does this through tags and
      APIs that allow you to get access to data over http, manipulate XML data in memory, and,
      significantly, bind the data hierarchy to the view hierarchy.</para>
    <!-- fix broken xref per LPP-4847 IORIO 7 oct 2007 -->
    <para>The following paragraphs summarize these key features of the LZX data-handling
      architecture. <xref linkend="data-structures"/> discusses this subject in depth.</para>


    <section>
      <title>Data Access</title>

      <para>LZX programs manipulate XML-formatted data, which may be</para>
      <itemizedlist spacing="compact">
        <listitem>
          <para> embedded in the program text, </para>
        </listitem>
        <listitem>
          <para> read in from a source when the program is compiled, or</para>
        </listitem>
        <listitem>
          <para> read in from a source when the program is running.</para>
        </listitem>
      </itemizedlist>

      <para>XML sources are stored as objects called datasets. The
        <literal>&lt;dataset&gt;</literal> tag has attributes that allow you to, for
        example, control caching on the client and server, include or exclude http headers, queue
        requests, and so forth. Objects created by <literal>&lt;dataset&gt;</literal> are
        called <literal>lz.dataset</literal>s. Methods on <literal>lz.dataset</literal>s allow you
        to, for example, get and set query strings, parameters and so forth.</para>


    </section>
    <section>
      <title> Data Manipulation</title>

      <para>LZX employs datapointers, which are objects that represent pointers to nodes in
        datasets, to locate and manipulate content. Datapointers support a subset of XPath, which is
        a W3C standard specification for identifying paths of an XML document, or in the case of
        LZX, datasets. XPath uses a notation similar to the UNIX file-system to refer to nodes
        within a dataset. Datapointers can be repositioned using both procedural calls such as
          <literal>selectNext()</literal> and by running an XPath request using
        <literal>setXPath()</literal>.</para>

      <para>Because it incorporates sophisticated pattern matching, XPath notation is extremely
        concise and powerful. A single XPath expression can represent an arbitrarily large number of
        XML elements. Using methods such as <literal>addNode()</literal>, <literal>setNodeName()</literal>
        <literal>setXpath()</literal>, and <literal>selectParent()</literal>, you can build and
        manipulate XML structures.</para>


    </section>
    <section>
      <title>Data Binding</title>

      <para>LZX provides a unique way of merging any arbitrarily shaped data hierarchy with any
        display hierarchy; this capability is called data binding. It is implemented in such a way
        that the data context of a child in the display hierarchy is implicitly the data context of
        its parent. Moreover, it is possible to instruct the system to create an arbitrary bit of
        view hierarchy to represent each element in a set of selected data.</para>

      <para>The way this is done is by binding views to datapointers. A <literal>datapath</literal>
        is a special case of datapointer that explicitly marries the data hierarchy to the view
        hierarchy, as in, for example:</para>

      <programlisting>&lt;view name="bob" datapath="testdata:/*"&gt;</programlisting>

      <para>where <literal>testdata</literal> refers to a dataset defined earlier in the program.</para>

      <!-- fix broken xref per LPP-4847 IORIO 7 oct 2007 -->
      <para>If this sounds a little abstract, well, it is. Therefore we'll keep the discussion short
        here and defer longer explanations to <xref linkend="databinding"/>; you may also want to
        examine some of the examples on <ulink url="http://openlaszlo.org/showcase"
          >http://openlaszlo.org/showcase</ulink> to get a feel for what can be done when
        applications are truly data-driven.</para>

      <para>The key thing to understand is that while other languages and technologies have
        implemented merge algorithms that may appear similar on the surface, LZX's data binding is
        novel in the creation of program objects that retain a live connection with the entities of
        the data source.</para>


    </section>
  </section>
  <section id="combine-tags-script">
    <title>Combining Tags and Script in LZX Programs</title>

    <para>As mentioned earlier, virtually all nontrivial LZX programs contain both (XML) tags and
      script. Tags are used declaratively, that is, to define objects and their attributes. Script
      is used procedurally, that is, to explicitly define a series of steps. Although the two kinds
      of code are liberally intermixed within LZX — for example, script can appear within tags —
      each syntax locally maintains its integrity.</para>

    <para>So for example, within declarative LZX code, comments are denoted</para>
    <programlisting>&lt;!-- XML comment --&gt;</programlisting>
    <para>while within JavaScript, comments are denoted</para>
    <programlisting>// JavaScript comment</programlisting>
    <para>Thus LZX is similar to an alloy of two metals that do not chemically combine.</para>

    <para>Because the declarative and procedural portions of a program can be so intertwined, it can
      be a little tricky, at first, to recognize them within a program. However, once you gain a
      little experience and begin to grasp the underlying logic of LZX you will find that you hardly
      notice the alternating syntaxes. The following paragraphs explain how and why to employ the
      two "flavors" of LZX. Consult the documentation for your IDE or text editor to learn how to
      use the LZX DTD or schema to give visual cues that indicate what portions of the program are
      in each syntax.</para>

    <section>
      <title>Name Mapping between Tags and Classes</title>
      <para> The preferred normalized form of class names is <literal>lz.[tagname]</literal> where
        [tagname] is the name of a tag. So for example a if you created a class called "bob":</para>
      <programlisting>
&lt;class name="bob"/&gt;
</programlisting>
      <para> then from the point of view of JavaScript, this would be an <literal>lz.bob</literal>
        object. </para>
      <para> In earlier versions of LZX (before OpenLaszlo 4), there was an asymmetric mapping
        between tag and class names, often of the form <literal>LzFoo &lt;—&gt;
          &lt;foo&gt;</literal>, as in the correspondence between, say the class name
          <literal>lz.view</literal> and the tag name <literal>&lt;view&gt;</literal>.
        (Notice in <literal>lz.view</literal> the mixed case, and the absence of the period between
        lz and the tag name.) Also there was a distinction between LFC classes and user-created
        classes. The new <literal>lz.foo</literal> form is consistent across LFC classes and
        user-created classes. The old forms will still work, and they appear throughout this
        documentation and in example code. As of OpenLaszlo 5.0, however, the old forms will be
        deprecated; it would be a good practice to adopt the new form in your code.</para>
    </section>
    <section>
      <title>How to Combine Tags and Script</title>

      <para>Let's start by making a distinction between what is syntactically allowable and what is
        meaningful.</para>

      <section>
        <title>What's Allowable</title>

        <para>Remember that all LZX programs are well-formed XML files. That means that all portions
          of the program, including embedded JavaScript, must conform to XML rules. Therefore where
          JavaScript uses characters that are meaningful to XML, such as the left angle bracket
          &lt;, you must make sure that those characters don't confuse the XML parser. You can
          do that in either of two ways:</para>

        <itemizedlist spacing="compact">
          <listitem>
            <para>by explicitly <emphasis>escaping</emphasis> delimiter characters with an
                <emphasis>entity reference</emphasis>. (For example, the entity reference for the
              left angle bracket is <literal>&amp;lt;</literal>).</para>
          </listitem>
          <listitem>
            <para>by using the XML <literal>CDATA</literal> construct to define a block of character
              data.</para>
          </listitem>
        </itemizedlist>

        <para>This is the sum total of rules for making sure that XML does not trip on JavaScript.</para>


      </section>
      <section>
        <title>What's Meaningful</title>

        <para>Although the admixture of two different sets of language rules in one language does
          create opportunities for confusion, it's fairly easy to recognize how LZX programs are
          structured, and what kind of code goes where. There are only a few contexts in which
          script code can appear in LZX programs. After you learn to recognize these contexts you
          are unlikely to be confused about what syntax applies. JavaScript is used:</para>
        <itemizedlist spacing="compact">
          <listitem>
            <para>between an opening and closing <literal>&lt;script&gt;</literal> and
                <literal>&lt;/script&gt;</literal> tag;</para>
          </listitem>
          <listitem>
            <para>between an opening and closing <literal>&lt;method&gt;</literal> and
                <literal>&lt;/method&gt;</literal> tag;</para>
          </listitem>
          <listitem>
            <para>between an opening and closing <literal>&lt;handler&gt;</literal> and
                <literal>&lt;/handler&gt;</literal> tag;</para>
          </listitem>
          <listitem>
            <para>with the double-quoted right hand value of an assignment statement within certain
              tags, such as <literal>oninit="<replaceable>script expression</replaceable>"</literal>
              .</para>
          </listitem>
        </itemizedlist>




      </section>
    </section>
    <section>
      <title>When to Use Tags and When to Use Script</title>

      <para>As we said earlier, most things that you can do in LZX can be done either with XML tags
        or JavaScript APIs, and mastering LZX requires developing a subtle understanding of how and
        when to use each. You will find, in general, that tags are best for computations that can be
        done at compile-time — such as laying out the canvas — and script is best for run-time
        things, such as responding to user input. But in order for you to make any use of that
        information you need to understand what is done at compile time and what is done at run
        time, and much of that is under your control, and dependent on the problem you're trying to
        solve.</para>

      <para>In other words, there is no simple set of unambiguous rules that tell you when to use
        tags versus when to use script. But there are, however, design patterns common to all
        well-made LZX programs.</para>

      <para>Remember, LZX is primarily a language for manipulating visual objects called views. So
        the question of when to use tags versus script is usually asked in the context of the
          <emphasis>creation of views and manipulation of their attributes</emphasis>. Script can be
        used for other things, such as global functions, but in those instances the need to write
        procedural code (i.e., script) is usually clear-cut. The finesse part has to do with
        manipulating views and their attributes.</para>

      <para>For example, a simple two-word constraint might express a relationship between views
        that would require thirty lines of code to express. Most of the time the constraint is the
        better programming solution. But not always.</para>

      <para>Although there are no absolutes, there are some general principles that define best
        practice in LZX development:</para>
      <itemizedlist spacing="compact">
        <listitem>
          <para> Use tags when that is the only option.</para>
        </listitem>
        <listitem>
          <para> Use JavaScript when that is the only option.</para>
        </listitem>
        <listitem>
          <para> If something can be done with either tags or script, use tags (unless there is a
            good reason not to).</para>
        </listitem>
      </itemizedlist>

      <para>Each of these principles is described briefly below.</para>
      <section>
        <title>Use tags when that is the only option</title>

        <para>There are certain tags that perform functions that cannot be done using script. For
          example, the root node (and enclosing tag) of every LZX program is
            <literal>&lt;canvas&gt;</literal>. Every LZX program begins with
            <literal>&lt;canvas&gt;</literal> and ends with
          <literal>&lt;/canvas&gt;</literal>; there is no alternative structure using
          script. Similarly there are no script equivalents for
          <literal>&lt;method&gt;</literal>, <literal>&lt;attribute&gt;</literal>,
            <literal>&lt;resource&gt;</literal> , and several other tags. Moreover, within
          certain tag definitions there are certain attributes that can only be set in the tag.</para>

      </section>
      <section>
        <title>Use JavaScript when that is the only option.</title>

        <para>There are several JavaScript APIs that perform functions that cannot be done using
          tags. For example, <literal>lz.event</literal> and similar APIs perform operations that
          cannot be done using tags. Similarly, there are certain attributes of objects that can
          only be referenced by script, even for objects that were created with tags. For example,
          consider</para>

        <para>
          <literal>&lt;view name="franklin"&gt;</literal>
        </para>

        <para>There is an attribute, <literal>franklin.subviews,</literal> that can be accessed by
          script; it is not possible to set or access that attribute in a tag.</para>

      </section>
      <section>
        <title>If something can be done with either tags or script, use tags.</title>

        <para>In the large number of cases where it is possible to do something using either tags or
          views, it is generally better to use tags. For example you can create a new view called
          "sam" using tags</para>

        <para>
          <literal>&lt;view name="sam"&gt;</literal>
        </para>
        <para>or script</para>
        <para>
          <literal>sam = new lz.view();</literal>
        </para>

        <para>When you use the tag syntax you can quite naturally create hierarchies of nested
          subviews, define attributes as constraints, and lay out your code in a way that helps you
          conceptualize the placement of views on the canvas. Achieving any of these results in pure
          JavaScript would be a colossal pain and negate much of the benefit of the language.
          Learning to think in LZX means learning to think in terms of views that act nearly
          autonomously according to the constraints you establish at their creation.</para>


      </section>
      <section>
        <title>Unless there is a good reason not to.</title>

        <para>Sometimes it's better to write procedural code instead of declarative code. This may
          become necessary, for example, to achieve optimal performance: multiply-constrained
          systems can sometimes become CPU bound. Other times procedural code may make your
          program's behavior easier to understand: complex rule-based view systems sometimes become
          inscrutable.</para>


      </section>
    </section>
  </section>
  <section>
    <title>Compilation and Execution</title>
    <para>LZX programs are compiled by the OpenLaszlo Compiler, downloaded as byte code or DHTML,
      and executed on the client. In writing your program you can make trade-offs between
      compilation performance, download and startup up time, and runtime performance.</para>

    <para>As in other scripting languages such as Perl and Python, LZX programs execute in
      approximately linear order. That is to say, if you were to write</para>

    <programlisting>
&lt;view name="outside"&gt; 
  &lt;view name="inside"/&gt; 
&lt;/view&gt;
</programlisting>

    <para>Then <literal>inside</literal> would be built before <literal>outside</literal>. However
      in many cases you may wish to control the order in which objects are built, or initialized.
      LZX gives you fine grained control over initialization and instantiation of views.</para>

  </section>

</chapter>
