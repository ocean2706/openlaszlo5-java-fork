<?xml version="1.0"?>
<!-- * X_LZ_COPYRIGHT_BEGIN ***************************************************
	* Copyright 2006-2011 Laszlo Systems, Inc.  All Rights Reserved.              *
	* Use is subject to license terms.                                            *
	* X_LZ_COPYRIGHT_END ****************************************************** -->
<js2doc>

	<property id="tag.switch" topic="LZX" subtopic="Basics" access="public">
		<doc>
			<tag name="shortdesc">
				<text>Special syntax used to control compilation</text>
			</tag>
			<tag name="lzxname">
				<text>switch</text>
			</tag>
			<tag name="usage">
				<text>
					<p> Each <code>&lt;when&gt;</code> block which evaluates to true will
						include that block of code in the compilation. This provides a mechanism to
						conditionally include alternate blocks of code, depending on the value of
						compile-time constants. </p>
					<p> The supported attributes for <code>&lt;when&gt;</code> are </p>
					<ul>
						<li>
							<code>&lt;property&gt;</code> , which looks at a boolean compile
							time property: for example <code>&lt;when
								property=&quot;$as3&quot;&gt;</code> checks for Boolean
							true. </li>

						<li>
							<code>&lt;property&gt;</code> with
							<code>&lt;value&gt;</code> , checks that the given compile time
							property equals the given literal value: for example <code>&lt;when
								property=&quot;$runtime&quot;
								value=&quot;swf9&quot;&gt;</code> checks for string
							equality. </li>

						<li> and, for back compatibility, the <code>&lt;runtime&gt;</code>
							attribute, equivalent to the above: <code>&lt;when
								runtime=&quot;swf9&quot;&gt;</code> . </li>
					</ul>

					<p>The possible compile time constants are:</p>

					<ul>
						<li>$runtime : string</li>
						<li>$swf7 : boolean</li>
						<li>$swf8 : boolean</li>
						<li>$as2 : boolean</li>
						<li>$swf9 : boolean</li>
						<li>$swf10 : boolean</li>
						<li>$as3 : boolean</li>
						<li>$dhtml : boolean</li>
						<li>$j2me : boolean</li>
						<li>$svg : boolean</li>
						<li>$js1 : boolean</li>
						<li>$debug : boolean</li>
						<li>$profile : boolean</li>
						<li>$backtrace : boolean</li>
					</ul>

					<p> The following examples show the use of the <code>&lt;with&gt;</code>
						, <code>&lt;unless&gt;</code> , and
						<code>&lt;otherwise&gt;</code> tags. </p>

					<example><![CDATA[
<canvas height="20" width="100%">
  <switch>
    <when property="$dhtml">
      <text>This program has been compiled for DHTML</text>
    </when>
    <otherwise>
      <text>This program has been compiled for SWF</text>
    </otherwise>
  </switch>
</canvas>
                    ]]></example>
					<p> You can also use <code>&lt;unless&gt;</code> in a similar way. </p>

					<example><![CDATA[
<canvas height="20" width="100%">
  <switch>
    <unless property="$swf10">
      <text>Not SWF10</text>
    </unless>
    <otherwise>
      <text>Must be SWF10</text>
    </otherwise>
  </switch>
</canvas>
                    ]]></example>
				</text>
			</tag>
		</doc>
		<class/>
	</property>

	<property id="tag.when" topic="LZX" subtopic="Basics" access="public">
		<doc>
			<tag name="shortdesc">
				<text> Within a <code>&lt;switch&gt;</code> block, use
						<code>&lt;when&gt;</code> to specify a compile-time constant.
				</text>
			</tag>
			<tag name="lzxname">
				<text>when</text>
			</tag>
			<tag name="usage">
				<text>
					<p> See the documentation for <sgmltag class="element" role="tag.switch"
							>&lt;switch&gt; </sgmltag> . </p>
				</text>
			</tag>
		</doc>
		<class/>
	</property>

	<property id="tag.unless" topic="LZX" subtopic="Basics" access="public">
		<doc>
			<tag name="shortdesc">
				<text> Within a <code>&lt;switch&gt;</code> block, use
						<code>&lt;unless&gt;</code> to specify a compile-time constant.
				</text>
			</tag>
			<tag name="lzxname">
				<text>unless</text>
			</tag>
			<tag name="usage">
				<text>
					<p> See the documentation for <sgmltag class="element" role="tag.switch"
							>&lt;switch&gt; </sgmltag> . </p>
				</text>
			</tag>
		</doc>
		<class/>
	</property>

	<property id="tag.otherwise" topic="LZX" subtopic="Basics" access="public">
		<doc>
			<tag name="shortdesc">
				<text> Within a <code>&lt;switch&gt;</code> block, use
						<code>&lt;otherwise&gt;</code> to specify a compile-time constant.
				</text>
			</tag>
			<tag name="lzxname">
				<text>otherwise</text>
			</tag>
			<tag name="usage">
				<text>
					<p> See the documentation for <sgmltag class="element" role="tag.switch"
							>&lt;switch&gt; </sgmltag> . </p>
				</text>
			</tag>
		</doc>
		<class/>
	</property>


	<property id="tag.mixin" topic="LZX" subtopic="Basics" access="public">
		<doc>
			<tag name="shortdesc">
				<text>
					<literal>&lt;mixin&gt;</literal> is like
					<literal>&lt;class&gt;</literal> but rather than creating something you
					can instantiate, <literal>&lt;mixin&gt;</literal> creates a template
					that can be mixed in (added to) more than one other class. A
						<literal>&lt;mixin&gt;</literal> is like an interface, but it is
					allowed to have state and implementation. </text>
			</tag>
			<tag name="lzxname">
				<text>mixin</text>
			</tag>
			<tag name="usage">
				<text>
					<p> This page describes an advanced usage of
						<literal>&lt;mixin&gt;</literal> . For a more basic usage, see <a
							href="${dguide}class-inheritance.html#mixins">Chapter 33. Extending
							Classes</a> in the Developers Guide. </p>

					<p>
						<literal>&lt;mixin&gt;</literal> s are a shorthand for creating
						intermediate anonymous classes (exactly as we do in our implementation):
						<programlisting class="code">&lt;class name=&quot;a&quot; extends=&quot;d&quot; with=&quot;b,c&quot; /&gt; </programlisting>
						is meant to be _exactly_ equivalent to:
						<programlisting class="code">
							<![CDATA[
<class name="cd" extends="d" implements="c">
 ... body of c ...
</class>

<class name="bcd" extends="cd" implements="b">
 ... body of b ...
</class>

<class name="a" extends="bcd">
 ... body of a ...
</class>
]]>
</programlisting>
					</p>

					<p> Except that the intermediate classes <literal>cd</literal> and
						<literal>bcd</literal> are anonymous. So it is a shorthand for re-using the
							<literal>mixin</literal> bodies in multiple classes with potentially
						different superclasses. The primary difference between
						<literal>trait</literal> and <literal>mixin</literal> is that
						<literal>trait</literal> simply disallows any case where you could not
						simply use textual substitution, whereas <literal>mixin</literal> appeals to
						the class inheritance semantics to resolve those cases (including being able
						to make super calls to overridden <literal>mixin</literal> methods). In the
						cases where there are no conflicting attributes, <literal>mixins</literal>
						can be optimized to <literal>traits</literal> and you can eliminate the
						intermediate classes. </p>
					<p>The simple model of how mixin inheritance works is that if you say:</p>

					<literal>&lt;class name=&quot;sundae&quot;
						extends=&quot;icecream&quot;
						with=&quot;sauce,whippedcream,nuts&quot;&gt;</literal>

					<p> methods are looked up first in the class ( <literal>sundae</literal> ) then
						in each of the <literal>mixins</literal> ( <literal>sauce</literal> , then
							<literal>whippedcream</literal> , then <literal>nuts</literal> ) and
						then in the super class chain ( <literal>icecream</literal> and then in any
						superclasses of <literal>icecream</literal> ). The <literal>mixin</literal>
						s are searched left-to-right, and then the superclass chain is searched. The
						key point is that <literal>mixin</literal> s precede the superclass, and
							<literal>mixin</literal> s are searched in the order they are listed.
						 This same search order is used when looking
							for methods, or attributes, or invoking super calls. </p>
					<p>The following example demonstrates the use of <literal>mixin</literal>s. See the comments in the code for a description of how it works.</p>
					<example>
<![CDATA[
<canvas width="100%" height="400" layout="axis: y; spacing: 25">
    <!--- The base class of all ice cream desserts -->
    <class name="icecream">
      <attribute name="flavor" type="color" value="vanilla" />
      <method name="toString">
        return this.presentAttribute('flavor', 'color') + " icecream";
      </method>
      <view width="100%" height="100%" bgcolor="${parent.flavor}" />
    </class>

    <!--- This parlour only offers walnuts -->
    <class name="walnuts" extends="view">
      <attribute name="bgcolor" value="brown" />
      <attribute name="ground" type="boolean" value="false" />
      <attribute name="opacity" value="${this.ground?.5:1}" />
      <method name="grind">
        this.setAttribute('ground', true);
      </method>
      <method name="toString">
        return (this.ground?"ground ":"") + "walnuts";
      </method>
    </class>

    <!--- This is the 'toppings' mixin, which could be added to various desserts -->
    <mixin name="toppings">
      <attribute name="sauce" type="color" value="chocolate" />
      <attribute name="whippedcream" type="boolean" value="true" />
      <attribute name="cherry" type="boolean" value="true" />

      <view name="layers" width="100%" layout="axis: y; spacing: 0" bgcolor="${canvas.bgcolor}">
        <view width="25" height="25" x="${(parent.width - this.width)/2}"
                visible="${classroot.cherry}" bgcolor="red" />
        <walnuts name="nuts" width="100%" height="10"
                 visible="${classroot.nuts}" ground="${classroot.ground}" />
        <view width="100%" height="25"
              visible="${classroot.whippedcream}" bgcolor="snow" />
        <view width="100%" height="10" bgcolor="${classroot.sauce}" />
      </view>

      <attribute name="nuts" type="boolean" value="false" />
      <attribute name="ground" type="boolean" value="false" />

      <method name="toString">
        return super.toString() + " with " +
          this.presentAttribute('sauce', 'color') + " sauce" +
          (this.whippedcream?", whipped cream":"") +
          (this.nuts?(", " + this.layers.nuts.toString()):"") +
          (this.cherry?", with a cherry on top":"");
      </method>
    </mixin>

    <!---
      Ok!  Let's build a dessert.  A sundae is based on icecream, and
      we mixin toppings.  The resulting class has the attributes of
      icecream and toppings, without us having to make toppings
      inherit from icecream.
    -->
    <class name="sundae" extends="icecream" with="toppings">
      <method name="toString">
        return super.toString() + " sundae";
      </method>
    </class>

    <class name="sundae2" extends="icecream" with="toppings">
      <method name="toString">
        return super.toString() + " sundae";
      </method>
    </class>
    <sundae2 visible="false"/>

    <attribute name="sauces" value="['chocolate', 'lavender', 'olive', 'orange', 'plum', 'snow', 'thistle', 'violet']" />
    <attribute name="icecreams" value="['bisque', 'honeydew', 'lemonchiffon', 'lime', 'mintcream', 'papayawhip', 'peachpuff', 'salmon', 'tomato', 'wheat']"  />

    <!--- Here's how you order your sundae -->
    <view name="recipe" x="5%" width="90%" layout="axis: y; spacing: 3">
      <text>
        Build your own sundae:
      </text>
      <checkbox name="cherry">Cherry?</checkbox>
      <view name="nutchoice" layout="axis: x; spacing: 3">
        <checkbox name="nuts">Nuts?</checkbox>
        <checkbox name="ground" enabled="${parent.nuts.getValue()}">Ground?</checkbox>
      </view>
      <checkbox name="whippedcream">Whipped Cream?</checkbox>
      <view name="saucechoice" layout="axis: x; spacing: 3">
        <text>Sauce:</text>
        <combobox name="sauce" editable="false">
          <replicator nodes="$once{canvas.sauces}">
            <textlistitem text="${this.presentValue()}" type="color" />
          </replicator>
        </combobox>
      </view>
      <view name="icecreamchoice" layout="axis: x; spacing: 3">
        <text>Ice Cream:</text>
        <combobox name="icecream" editable="false">
          <replicator nodes="$once{canvas.icecreams}">
            <textlistitem text="${this.presentValue()}" type="color" />
          </replicator>
        </combobox>
      </view>
    </view>

    <!--- And here's your WYSIWYG sundae -->
    <sundae id="yoursundae"
            width="100" height="150"
            x="${(this.parent.width - this.width)/2}"
            flavor="${recipe.icecreamchoice.icecream.getValue()}"
            sauce="${recipe.saucechoice.sauce.getValue()}"
            nuts="${recipe.nutchoice.nuts.getValue()}"
            ground="${recipe.nutchoice.ground.getValue()}"
            whippedcream="${recipe.whippedcream.getValue()}"
            cherry="${recipe.cherry.getValue()}"
    />

    <!--- If you want the recipe for your sundae, push the button -->
    <button x="${(this.parent.width - this.width)/2}"
            onclick="description.format('You built a %s', yoursundae)">
      Tell me the recipe!
    </button>

    <!--- And the recipe will show up here -->
    <text name="description" x="5%" width="90%" multiline="true" />
</canvas>]]>
</example>
				</text>
			</tag>
		</doc>
		<class/>
	</property>

	<property id="tag.class" topic="LZX" subtopic="Basics" access="public">
		<doc>
			<tag name="shortdesc">
				<text>Provides a prototype for all objects of that class</text>
			</tag>
			<tag name="lzxname">
				<text>class</text>
			</tag>
			<tag name="usage">
				<text>
					<p>A <literal>class</literal> describes the state and behavior that all objects of that class share. An object of a given class is called an <literal>instance</literal> of that class.</p>
					<p>The following example defines the class <literal>Hello</literal>, and instantiates <literal>myHello</literal> (an instance of that class).</p>
					<example><![CDATA[
<canvas width="100%" height="50">
  <class name="Hello" width="80" height="25" bgcolor="#CFD9AB">
    <text align="center" valign="middle">Hello, World!</text>
  </class>

  <Hello name="myHello"/>
</canvas>
                    ]]></example>
					<p>For a complete description of classes and how you use them, see the following chapters in the Developers Guide:
					</p>
					<ul>
						<li><a href="${dguide}tutorials/classes-tutorial.html">Chapter 12. Introduction to Classes and Object Oriented Programming</a></li>
						<li><a href="${dguide}introductory-classes.html">Chapter 28. Classes</a></li>
						<li><a href="${dguide}class-inheritance.html">Chapter 33. Extending Classes</a></li>
					</ul>
				</text>
			</tag>
		</doc>
		<class/>
	</property>
<!-- decided not to document interface (10/13 weekly meeting)
	<property id="tag.interface" topic="LZX" subtopic="Basics" access="public">
		<doc>
			<tag name="shortdesc">
				<text>
					<literal>&lt;interface&gt;</literal> ... </text>
			</tag>
			<tag name="lzxname">
				<text>interface</text>
			</tag>
			<tag name="usage">
				<text>
					<p>placeholder</p>
				</text>
			</tag>
		</doc>
		<class/>
	</property>
-->
	<property id="tag.passthrough" topic="LZX" subtopic="Basics" access="public">
		<doc>
			<tag name="shortdesc">
				<text>Provides a way to import SWF10 declarations.</text>
			</tag>
			<tag name="lzxname">
				<text>passthrough</text>
			</tag>
			<tag name="usage">
				<text>
					<p>
						<literal>&lt;passthrough&gt;</literal> tells the class compiler to
						import SWF10 declarations. For example, in
							<literal>lps/components/extensions/av/microphone.lzx</literal>:</p>
					<programlisting> &lt;class name=&quot;microphone&quot; extends=&quot;mediadevice&quot;&gt;
	&lt;passthrough when=&quot;$as3&quot;&gt;
		import flash.media.*;
	&lt;/passthrough&gt;
	
	...</programlisting>
					<p>You can also use <literal>passthrough</literal> in script. For example, in
							<literal>lps/components/extensions/drawview.lzx</literal>:</p>
					<programlisting>&lt;script when=&quot;immediate&quot;&gt;&lt;![CDATA[
	// Classes that implement an interface must obey the LZX
	// tag->class mapping convention and must be dynamic
	dynamic class $lzc$class_drawview extends LzView with DrawviewShared {
	    if ($as3) {
	        #passthrough (toplevel:true) {
	        import flash.geom.Matrix;
	        import flash.geom.Rectangle;
	        import flash.display.Bitmap;
	        import flash.display.BitmapData;
	        import flash.display.Graphics;
	        import flash.display.Sprite;
	        }#
	    }
	    
	    ...</programlisting>
					<p><literal>toplevel:true</literal> makes the swf10 backend put the code outside
						of and before the class declaration (the only place that
						<literal>import</literal> statements can go).</p>
					<p>The possible compile time constants are:</p>
					
					<ul>
						<li>$runtime : string</li>
						<li>$swf7 : boolean</li>
						<li>$swf8 : boolean</li>
						<li>$as2 : boolean</li>
						<li>$swf9 : boolean</li>
						<li>$swf10 : boolean</li>
						<li>$as3 : boolean</li>
						<li>$dhtml : boolean</li>
						<li>$j2me : boolean</li>
						<li>$svg : boolean</li>
						<li>$js1 : boolean</li>
						<li>$debug : boolean</li>
						<li>$profile : boolean</li>
						<li>$backtrace : boolean</li>
					</ul>
				</text>
			</tag>
		</doc>
		<class/>
	</property>

	<property id="tag.attribute" topic="LZX" subtopic="Basics" access="public">
		<doc>
			<tag name="shortdesc">
				<text>Sets an attribute of the object that contains it.</text>
			</tag>
			<tag name="lzxname">
				<text>attribute</text>
			</tag>
			<text>
				<p> The <tagname>attribute</tagname> tag has two uses: </p>

				<ol>

					<li>
						<p> In a class definiiton, the <tagname>attribute</tagname> tag defines an
							attribute that can be set in instances of the class. </p>

						<example><![CDATA[
<canvas height="30">
  <class name="mybutton" extends="button">
    <attribute name="myattr" type="string" value=""/>
  </class>
  <mybutton text="before" myattr="after"
      onclick="setAttribute('text', this.myattr)"/>
</canvas>
                        ]]></example>
					</li>

					<li>
						<p> In an instance, the <tagname>attribute</tagname> tag attaches an
							attribute to the instance. The attribute can be accessed from script. </p>

						<example><![CDATA[
<canvas height="30">
  <class name="mybutton" extends="button">
    <attribute name="myattr" type="string" value=""/>
  </class>
  <mybutton text="before"
      onclick="setAttribute('text', this.myattr)">
    <attribute name="myattr" value="perhaps later"/>
  </mybutton>
</canvas>
                        ]]></example>

					</li>
				</ol>

				<p> See the <link linkend="methods-events-attributes.attribute-tag">Developer's
						Guide</link> for a complete discussion. </p>

				<p> Also see the documentation for <sgmltag class="element" role="tag.class"
						>&lt;class&gt; </sgmltag> . The <a
						href="${tutorials}classes-tutorial.html">Classes</a> tutorial describes how
					to use attributes to define a class. </p>
			</text>
		</doc>
		<class>
			<property name="__ivars__" access="public">
				<object>
					<property name="name" id="attribute.__ivars__.name" modifiers="final"
						type="String">
						<doc>
							<text>The name of the attribute.</text>
						</doc>
					</property>
					<property name="style" id="attribute.__ivars__.style" modifiers="final"
						type="String">
						<doc>
							<text> The CSS property name that can be used to set the value of this
								attribute under the control of a
								<literal>&lt;stylesheet&gt;</literal> (See <a
									href="${dguide}css.html">Chapter 19. Cascading Style Sheets</a>
								). <literal>style</literal> can be any valid CSS property name, and
								need not be the same as the attribute name; for example you could
								use the standard CSS property name
								<literal>background-color</literal> as the style of the
									<literal>bgcolor</literal> attribute. When an attribute has a
									<literal>style</literal> property, the <literal>value</literal>
								property acts as the default value for the attribute: in the absence
								of any applicable CSS rule specifying the corresponding property,
								the attribute will be given the default value. In the case of
								dynamic CSS, the attribute will revert to the default value if CSS
								was applied and is removed. (See <a
									href="${dguide}css.html#dynamiccss">Dynamic CSS</a> .) </text>
						</doc>
					</property>
					<property name="value" id="attribute.__ivars__.value" type="Object">
						<doc>
							<text>The initial value of the attribute. The type of this value is
								specified by the value of the type attribute; if that attribute is
								not present, it's the type of this attribute in this element's tag.
								The attribute is given this value when the element is created.
							</text>
						</doc>
					</property>
					<!--
						<property name="when" modifiers="final"
						id="attribute.__ivars__.when" access="private"> <doc> <tag
						name="since"> <text>1.1</text> </tag> <tag name="lzxdefault">
						<text>"immediately"</text> </tag> <tag name="lzxtype">
						<text>"immediately" | "once" | "always"</text> </tag> <text> When
						the initial value expression is to be evaluated. One of: <dl> <dt>
						<literal>immediately</literal> </dt> <dd>evaluate when the
						enclosing element is defined (must be a constant)</dd> <dt>
						<literal>once</literal> </dt> <dd>evaluate when the enclosing
						element is initialized</dd> <dt> <literal>always</literal> </dt>
						<dd>update whenever the value of the expression changes</dd> </dl>
						The default is <literal>when="immediately"</literal>. The setting
						for <literal>when</literal> can be overridden when assigning a
						value to an attribute by using the syntax <code><var>attribute
						name</var>=$<var>when value</var>{<var>expression</var>}</code>.
						The default for <var>when value</var> is
						<literal>always</literal>, for example: <code>&lt;view
						title="$once{computeTitle()}" /&gt;</code> sets the title of the
						view to a computed value and <code>&lt;view
						title="${parent.subtitle}" \&gt;</code> will cause the title of
						the view to track <literal>parent.subtitle</literal>. </text>
						</doc> </property>
					-->
					<property name="allocation" modifiers="final"
						id="attribute.__ivars__.allocation">
						<doc>
							<tag name="lzxdefault">
								<text>"instance"</text>
							</tag>
							<tag name="lzxtype">
								<text>"instance" | "class"</text>
							</tag>
							<text> One of: <dl>
									<dt>
										<literal>class</literal>
									</dt>
									<dd> The attribute will be an attribute of the class; to refer
										to it, you say <literal>lz.classname.attributename</literal>
										. </dd>
									<dt>
										<literal>instance</literal>
									</dt>
									<dd> Each instance will have an attribute with the specified
										properties ( <literal>name</literal> ,
										<literal>type</literal> , <literal>value</literal> , etc.).
									</dd>
								</dl>
								<p> You can set <literal>allocation</literal> to
									<literal>class</literal> to get static attributes. Static
									properties are attached to the class itself, for example
										<literal>lz.classname</literal> . </p>
								<programlisting>&lt;attribute name="allowed" value="false"
									type="boolean" allocation="class" /&gt;</programlisting>
							</text>
						</doc>
					</property>
					<property name="type" type="String" modifiers="final"
						id="attribute.__ivars__.type">
						<doc>
							<tag name="lzxdefault">
								<text>"expression"</text>
							</tag>
							<tag name="lzxtype">
								<text>"boolean" | "color" | "expression" | "number" | "size" |
									"string" | "text" | "html"</text>
							</tag>
							<text>The type of the attribute. This determines how the value is
								parsed. Attributes of type string are automatically quoted if
								when="immediate", for any other value of when, a literal string
								would have to be quoted to be used as a value. </text>
						</doc>
					</property>
					<property name="required" type="Boolean" modifiers="final"
						id="attribute.__ivars__.required">
						<doc>
							<tag name="lzxdefault">
								<text>"false"</text>
							</tag>
							<text>True if this is a required attribute.</text>
						</doc>
					</property>
					<property name="setter" type="Object" access="protected"
						id="attribute.__ivars__.setter">
						<doc>
							<tag name="lzxtype">
								<text>script</text>
							</tag>
							<tag name="since">
								<text>1.1</text>
							</tag>
							<text>Code that is executed when setAttribute is used to set the value
								of this attribute. This code is executed within a context in which
								the variable with this attribute's name is bound to the value passed
								to setAttribute. </text>
						</doc>
					</property>
				</object>
			</property>
		</class>
	</property>

	<property id="tag.import" topic="LZX" subtopic="Basics" access="public">
		<doc>
			<tag name="shortdesc">
				<text>Imports code at runtime from other files.</text>
			</tag>
			<tag name="lzxname">
				<text>import</text>
			</tag>
			<text>
				<p> The <tagname>import</tagname> tag is used to import, at run time, source code
					contained in another (library) file. See the <a
						href="${dguide}program-structure.html#program-structure.include-tag"
					>Guide</a> for a complete discussion. Also see the <sgmltag class="element"
						role="tag.library">&lt;library&gt; </sgmltag> tag. </p>
			</text>
		</doc>
		<class extends="LzNode">
			<property name="__ivars__" access="public">
				<object>
					<property name="href" type="String">
						<doc>
							<tag name="lzxtype">
								<text>xsd:anyURI</text>
							</tag>
							<text>A reference to a target file whose content is treated as a
								loadable module</text>
						</doc>
					</property>
					<property name="onload">
						<doc>
							<tag name="lzxtype">
								<text>event</text>
							</tag>
						</doc>
					</property>
					<property name="onerror">
						<doc>
							<tag name="lzxtype">
								<text>event</text>
							</tag>
						</doc>
					</property>
					<property name="ontimeout">
						<doc>
							<tag name="lzxtype">
								<text>event</text>
							</tag>
						</doc>
					</property>
					<property name="proxied">
						<doc>
							<tag name="lzxtype">
								<text>boolean | "inherit"</text>
							</tag>
							<tag name="lzxdefault">
								<text>"inherit"</text>
							</tag>
						</doc>
					</property>
					<property name="stage">
						<doc>
							<tag name="lzxtype">
								<text>"late" | "defer"</text>
							</tag>
						</doc>
					</property>
				</object>
			</property>
		</class>
	</property>

	<property id="tag.include" topic="LZX" subtopic="Basics" access="public">
		<doc>
			<tag name="shortdesc">
				<text>Includes code from other files.</text>
			</tag>
			<tag name="lzxname">
				<text>include</text>
			</tag>
			<text>
				<p> The <tagname>include</tagname> tag is used to include source code contained in
					another file. See the <a
						href="${dguide}program-structure.html#program-structure.include-tag">
					Guide</a> for a complete discussion. Also see the <sgmltag class="element"
						role="tag.library">&lt;library&gt;</sgmltag> tag. </p>
			</text>
		</doc>
		<class>
			<property name="__ivars__" access="public">
				<object>
					<property name="href" type="String">
						<doc>
							<tag name="lzxtype">
								<text>xsd:anyURI</text>
							</tag>
							<text>A reference to a target file whose content is included in the
								application that contains this include element. </text>
						</doc>
					</property>
					<property name="type" type="String">
						<doc>
							<tag name="lzxtype">
								<text>"text" | "xml"</text>
							</tag>
							<tag name="lzxdefault">
								<text>"xml"</text>
							</tag>
							<text> If this attribute has the value <literal>text</literal> , the
								content of the target file is included as text. Otherwise, it is
								read as XML. </text>
						</doc>
					</property>
				</object>
			</property>
		</class>
	</property>

	<property id="tag.library" topic="LZX" subtopic="Basics" access="public">
		<doc>
			<tag name="shortdesc">
				<text>This tag marks the root element of a library file.</text>
			</tag>
			<tag name="lzxname">
				<text>library</text>
			</tag>
			<text>
				<p> The <tagname>library</tagname> tag defines the root element of a library file.
					An application can use the <sgmltag class="element" role="tag.include"
						>&lt;include&gt; </sgmltag> tag to include the code in a library
					file. </p>

				<p> See the <a href="${dguide}program-structure.html#program-structure.library-tag"
						>Guide</a> for a complete discussion. Also see the <sgmltag class="element"
						role="tag.include">&lt;include&gt; </sgmltag> tag. </p>
			</text>
		</doc>
		<class>
			<property name="__ivars__" access="public">
				<object>
					<property name="href" id="library.__ivars__.href" type="String" access="private">
						<doc>
							<tag name="lzxtype">
								<text>xsd:anyURI</text>
							</tag>
							<text>This attribute is used internally by the compiler. It shouldn't be
								used in user programs. </text>
						</doc>
					</property>
					<property name="proxied" id="library.__ivars__.proxied" access="public">
						<doc>
							<tag name="lzxtype">
								<text>boolean | "inherit"</text>
							</tag>
							<tag name="lzxdefault">
								<text>"inherit"</text>
							</tag>
						</doc>
					</property>
					<property name="validate" id="library.__ivars__.validate" access="public">
						<doc>
							<tag name="lzxtype">
								<text>boolean</text>
							</tag>
							<tag name="lzxdefault">
								<text>"true"</text>
							</tag>
							<text>If false, disables validation against the schema during
								compilation.</text>
						</doc>
					</property>
				</object>
			</property>
		</class>
	</property>

	<property id="tag.method" topic="LZX" subtopic="Basics" access="public">
		<doc>
			<tag name="shortdesc">
				<text>Attaches a function or event handler to an object or class. </text>
			</tag>
			<tag name="lzxname">
				<text>method</text>
			</tag>
			<text>
				<p> Attaches a method to the object that contains this element. The method must have
					a <attribute>name</attribute> . </p>

				<p> The <attribute>name</attribute> attribute allows the method to be invoked from
					JavaScript with this name. For example, if a method is defined via: </p>

				<!--<example extract="false">-->
				<programlisting class="code">
					&lt;view id="obj"&gt;
					&lt;method name="f" args="a, b"&gt;
					return a+b;
					&lt;/method&gt;
					&lt;/view&gt; </programlisting>
				<!--</example>-->

				<p> then script code can invoke <code>obj.f(1, 2)</code> to add two numbers. </p>
			</text>
		</doc>
		<class>
			<property name="__ivars__" access="public">
				<object>
					<property name="allocation" modifiers="final" id="method.__ivars__.allocation">
						<doc>
							<tag name="lzxdefault">
								<text>"instance"</text>
							</tag>
							<tag name="lzxtype">
								<text>"instance" | "class"</text>
							</tag>
							<text> One of: <dl>
									<dt>
										<literal>class</literal>
									</dt>
									<dd> The attribute will be an attribute of the class; to refer
										to it, you say <literal>lz.classname.attributename</literal>
										. </dd>
									<dt>
										<literal>instance</literal>
									</dt>
									<dd> Each instance will have a method with the specified
										properties ( <literal>name</literal> , or
										<literal>args</literal> ). </dd>
								</dl>
								<p> You can set <literal>allocation</literal> to
									<literal>class</literal> to get static attributes. Static
									properties are attached to the class itself, for example
										<literal>lz.classname</literal> . </p>
								<programlisting>&lt;attribute name="allowed" value="false"
									type="boolean" allocation="class" /&gt;</programlisting>
							</text>
						</doc>
					</property>
					<property name="name" type="" modifiers="final">
						<doc>
							<tag name="lzxtype">
								<text>token</text>
							</tag>
							<text> The name of a variable that will be set to this object when the
								application is started. If this element is directly within a <a
									href="../reference/lz.canvas.html">canvas</a> or <a
									herf="../reference/lz.library.html">library</a> element, the global
								variable and the canvas property with this name will be set to this
								object. If this element is within another object, that object's
								property with this name will be set to this object. </text>
						</doc>
					</property>
					<property name="args" type="" modifiers="final">
						<doc>
							<tag name="lzxtype">
								<text>string</text>
							</tag>
							<text>The parameter names of this method. The value of this attribute is
								a comma-separated list of JavaScript identifiers.</text>
						</doc>
					</property>
				</object>
			</property>
		</class>
	</property>

	<property id="tag.splash+as2" topic="LZX" subtopic="Basics" access="public" runtimes="swf8">
		<doc>
			<tag name="shortdesc">
				<text>Controls the presentation while the application is loading. </text>
			</tag>
			<tag name="lzxname">
				<text>splash</text>
			</tag>
			<text>
				<note> The <tagname>splash</tagname> tag does not work across all platforms.
					Consider instead the following technique: <!-- Note: does not work as a live example -->
					<programlisting><![CDATA[
<div id="lzsplash" style="z-index: 10000000; top: 0; left: 0; width: 100%; height: 100%; position: fixed; display: table">
  <p style="display: table-cell; vertical-align: middle;">
    <img src="/trunk/lps/includes/spinner.gif" style="display: block; margin: 20% auto"/>
  </p>
</div>
<script type="text/javascript">
  lz.embed.dhtml({url: 'copy-of-hello.lzx?lzt=object&lzr=dhtml', bgcolor: '#ffffff', width: '100%', height: '100%', id: 'lzapp'});
  lz.embed['lzapp'].onload = function loaded() {
    var s = document.getElementById('lzsplash');
    if (s) LzSprite.prototype.__discardElement(s);
  }
</script>]]></programlisting>
				</note>
				<p> The <tagname>splash</tagname> tag controls the presentation while the
					application is loading. </p>

				<p> If the <tagname>splash</tagname> element is present but is empty, a progress bar
					is displayed while the application is loading. For example: </p>

				<!--<example extract="false">-->
				<programlisting class="code">
					&lt;canvas&gt;
					&lt;splash/&gt;
					&lt;canvas&gt; </programlisting>
				<!--</example>-->

				<p> The <tagname link="true">splash</tagname> element may contain <a
						href="lz.splash_view.html">"splash view"</a> elements to define the
					position and behavior of resources that are displayed during the load process.
					However, these <a href="lz.splash_view.html">"splash view"</a> elements,
					although they are declared with a "view" tag, have a limited feature set. That
					is to say, when you place a <a href="lz.splash_view.html">view</a> tag inside a
						<tagname link="true">splash</tagname> element, you are not getting the same
					object that you do when you place a <sgmltag class="element" role="LzView"
						>&lt;view&gt;</sgmltag> tag elsewhere on the canvas. </p>
				<p> For example, the following program positions an image on the canvas during the
					"splash" loading portion of the program's execution and removes it once the
					application has loaded. The example below executes too quickly to be demonsrate
					the splash view; try it in a larger application to see how it works.</p>

				<!--<example extract="false" title="using 'splash view' tag">-->
				<programlisting class="code">
					&lt;canvas height="120"&gt;
					&lt;splash&gt;
					&lt;view resource="../images/logo.png"/&gt;
					&lt;/splash&gt;
					&lt;/canvas&gt; </programlisting>
				<!--</example>-->
				<p> You can position more than one image by specifying its coordinates. The
						<attribute>persistent</attribute> attribute on <tagname>splash</tagname> tag
					causes the "splash" views contained within the splash element to remain on the
					canvas once the load process is complete. </p>
				<example title="persisting splash views"> &lt;canvas height="120"&gt;
					&lt;splash persistent="true"&gt; &lt;view x="5"
					resource="../images/logo.png" /&gt; &lt;view x="50"
					resource="../images/logo.png" /&gt; &lt;view x="150"
					resource="../images/logo.png" /&gt; &lt;/splash&gt;
					&lt;/canvas&gt; </example>

			</text>
		</doc>
		<class>
			<property name="__ivars__" access="public">
				<object>
					<property name="hideafterinit" type="Boolean" access="private">
						<doc>
							<tag name="lzxtype">
								<text>boolean</text>
							</tag>
						</doc>
					</property>
					<property name="persistent">
						<doc>
							<tag name="lzxtype">
								<text>boolean</text>
							</tag>
							<tag name="lzxdefault">
								<text>"false"</text>
							</tag>
							<text>If true, the splash views remain on the canvas after the preload
								is complete. </text>
						</doc>
					</property>
				</object>
			</property>
		</class>
	</property>

	<property id="tag.splash-view" topic="LZX" subtopic="Basics" access="public" runtimes="swf8">
		<doc>
			<tag name="shortdesc">
				<text>A view element within the splash element positions a resource on the canvas
					while the application is loading.</text>
			</tag>
			<tag name="lzxname">
				<text>splash view</text>
			</tag>
			<text>
				<p> A <tagname>view</tagname> tag within a <tagname>splash</tagname> element defines
					a view that is used to present a resource while the application is loading. </p>

				<p> Only a few attributes of the standard <tagname>view</tagname> element can be
					used on this view, because it is displayed before most of the system is present. </p>

				<p> See the <tagname>splash</tagname> documentation for examples. </p>

			</text>
		</doc>
		<class>
			<property name="__ivars__" access="public">
				<object>
					<property name="name" type="String" modifiers="final">
						<doc>
							<text>This defines both a resource with this name, and a view. </text>
						</doc>
					</property>
					<property name="resource" type="String" modifiers="final">
						<doc>
							<text>This must be a pathname. If the target contains text, the text
								should be converted to outlines.</text>
						</doc>
					</property>
					<property name="ratio" type="Number" modifiers="read-only">
						<doc>
							<tag name="lzxtype">
								<text>number</text>
							</tag>
							<text>If this attribute is present, the resource is synchronized to
								loading progress. Its value should be either a number between 0.0
								and 1.0, or a percentage between 0% and 100% (inclusive). If the
								resource is a multiframe resource, the value is the proportion of
								the frames to play during the preload phase of application load; the
								remainder is played during the initialization phase. </text>
						</doc>
					</property>
					<property name="x" type="Number">
						<doc>
							<tag name="lzxtype">
								<text>number</text>
							</tag>
							<tag name="lzxdefault">
								<text>"0"</text>
							</tag>
							<text>x position of this view relative to the canvas</text>
						</doc>
					</property>
					<property name="y" type="Number">
						<doc>
							<tag name="lzxtype">
								<text>number</text>
							</tag>
							<tag name="lzxdefault">
								<text>"0"</text>
							</tag>
							<text>y position of this view relative to the canvas</text>
						</doc>
					</property>
					<property name="center" type="Boolean">
						<doc>
							<tag name="lzxtype">
								<text>boolean</text>
							</tag>
							<tag name="lzxdefault">
								<text>"false"</text>
							</tag>
							<text>If true, this view is centered within the canvas. This overrides
								the x and y attributes. </text>
						</doc>
					</property>
				</object>
			</property>
		</class>
	</property>

	<property id="tag.security" topic="LZX" subtopic="Basics" access="public">
		<doc>
			<tag name="shortdesc">
				<text>Canvas element used to control RPC security</text>
			</tag>
			<tag name="lzxname">
				<text>security</text>
			</tag>
			<tag name="usage">
				<text>
					<code> &lt;security&gt; &lt;allow&gt;
						<replaceable>pattern</replaceable> &lt;/allow&gt;
						<replaceable>...</replaceable> &lt;deny&gt;
						<replaceable>pattern</replaceable> &lt;/deny&gt;
						<replaceable>...</replaceable> &lt;/security&gt; </code>
				</text>
			</tag>
			<text>
				<p> Java classes used in JavaRPC application must be declared in a security element.
					Classes not defined in a security element are not allowed to be accessed or
					instantiated. The format of the security element looks like: </p>
				<!--<example extract="false">-->
				<programlisting class="code">
					&lt;security&gt;
					&lt;allow&gt;
					&lt;pattern&gt;CLASS1&lt;/pattern&gt;
					&lt;pattern&gt;CLASS2&lt;/pattern&gt;
					...
					&lt;pattern&gt;CLASSN&lt;/pattern&gt;
					&lt;/allow&gt;
					&lt;/security&gt; </programlisting>
				<!--</example>-->

				<p>Each &lt;pattern&gt; is a regular expression.</p>

				<!--
					<example extract="false" title="Allow classes that start with
					org.openlaszlo">
				-->
				<programlisting class="code">
					&lt;security&gt;
					&lt;allow&gt;
					&lt;pattern&gt;^org\.openlaszlo&lt;/pattern&gt;
					&lt;/allow&gt;
					&lt;/security&gt; </programlisting>
				<!--</example>-->

				<p>A javarpc object who's class is not declared in a security tag will result in a
					load error.</p>

				<example><![CDATA[<canvas debug="true" height="300">

    <debug x="10" y="40" height="240" />

    <security>
        <allow>
            <pattern>^examples\.ConstructExample</pattern>
        </allow>
    </security>

    <!-- See $LPS_HOME/WEB-INF/classes/examples/ConstructExample.java for java
        source. -->
    <javarpc name="ce" scope="session" remoteclassname="examples.ConstructExample"
             createargs="[1]" autoload="false">
        <handler name="onerror" args="err">
            Debug.debug("onerror: %w", err)
        </handler>
        <handler name="onload">
            Debug.debug("proxy loaded: %w", this.proxy);
        </handler>
    </javarpc>

    <!-- See $LPS_HOME/WEB-INF/classes/examples/TypesExample.java for java
         source. This will fail because class is not declared in security
         pattern-->
    <javarpc name="te" scope="session" remoteclassname="examples.TypesExample"
             autoload="false">
        <handler name="onerror" args="err">
            Debug.debug("onerror: %w", err)
        </handler>
        <handler name="onload">
            Debug.debug("proxy loaded: %w", this.proxy);
        </handler>
    </javarpc>

    <view x="10" y="10" layout="axis: x; spacing: 5">
        <button text="Load ConstructExample (allowed)"
                onclick="canvas.ce.load()" />
        <button text="Load TypesExample (not allowed)"
                onclick="canvas.te.load()" />
    </view>

</canvas>
]]></example>

				<p>
					<b>See Also:</b>
				</p>
				<ul>
					<li>
						<sgmltag class="element" role="lz.rpc">&lt;rpc&gt;</sgmltag>
					</li>
					<li>
						<sgmltag class="element" role="lz.javarpc">&lt;javarpc&gt;</sgmltag>
					</li>
					<li>
						<a href="${dguide}/rpc.html" target="laszlo-dguide" shape="rect">Developer's
							Guide: RPC chapter</a>
					</li>
					<li>
						<a href="${dguide}/rpc-javarpc.html" target="laszlo-dguide" shape="rect"
							>Developer's Guide: JavaRPC chapter</a>
					</li>
				</ul>

			</text>
		</doc>
		<class/>
	</property>

</js2doc>
